<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CSP Subtool Converter Pro - Hybrid Edition (JS + Python)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#fff}
.container{max-width:1400px;margin:0 auto;background:rgba(255,255,255,0.95);border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,0.3);overflow:hidden}
.header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:30px;text-align:center}
.header h1{font-size:clamp(1.5em,4vw,2.5em);margin-bottom:10px;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.2)}
.header p{opacity:0.9;font-size:1.1em}
.content{padding:clamp(20px,4vw,40px);color:#333}
.mode-selector{display:flex;gap:10px;margin-bottom:20px;background:#f8f9fa;padding:15px;border-radius:10px}
.mode-btn{flex:1;padding:12px;border:2px solid #dee2e6;background:#fff;border-radius:8px;cursor:pointer;font-weight:500;transition:all 0.3s}
.mode-btn.active{border-color:#667eea;background:#667eea;color:#fff}
.mode-btn:hover:not(.active){border-color:#667eea;background:#f8f9ff}
#dropZone{border:3px dashed #667eea;border-radius:15px;padding:clamp(40px,8vw,60px) clamp(20px,4vw,30px);text-align:center;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);transition:all 0.3s ease;cursor:pointer;margin-bottom:30px}
#dropZone:hover{border-color:#764ba2;transform:translateY(-2px);box-shadow:0 10px 30px rgba(102,126,234,0.3)}
#dropZone.dragover{border-color:#00d4ff;background:linear-gradient(135deg,#e0f7fa 0%,#b2ebf2 100%);transform:scale(1.02)}
#dropZone svg{width:clamp(48px,8vw,64px);height:clamp(48px,8vw,64px);margin-bottom:20px;opacity:0.7}
.controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:20px;margin-bottom:30px}
.control-group{background:#f8f9fa;padding:20px;border-radius:10px;border:1px solid #e9ecef}
.control-group label{display:block;font-weight:600;margin-bottom:8px;color:#495057;font-size:0.9em}
input[type=text],input[type=number],select{width:100%;padding:10px;border:2px solid #dee2e6;border-radius:8px;font-size:1em;transition:border-color 0.3s}
input[type=text]:focus,input[type=number]:focus,select:focus{outline:none;border-color:#667eea}
input[type=range]{width:100%;margin:10px 0}
.range-value{display:inline-block;background:#667eea;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85em;margin-left:10px}
.btn{padding:15px 40px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;border:none;border-radius:10px;cursor:pointer;font-size:1.1em;font-weight:600;transition:all 0.3s;box-shadow:0 4px 15px rgba(102,126,234,0.4);display:inline-flex;align-items:center;gap:10px;width:100%;justify-content:center}
.btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 20px rgba(102,126,234,0.6)}
.btn:disabled{background:#adb5bd;cursor:not-allowed;box-shadow:none}
.btn-secondary{background:linear-gradient(135deg,#6c757d 0%,#495057 100%);box-shadow:0 4px 15px rgba(108,117,125,0.4)}
.btn-secondary:hover:not(:disabled){box-shadow:0 6px 20px rgba(108,117,125,0.6)}
.btn-danger{background:linear-gradient(135deg,#dc3545 0%,#c82333 100%);box-shadow:0 4px 15px rgba(220,53,69,0.4)}
.btn-danger:hover:not(:disabled){box-shadow:0 6px 20px rgba(220,53,69,0.6)}
.btn-success{background:linear-gradient(135deg,#28a745 0%,#20c997 100%);box-shadow:0 4px 15px rgba(40,167,69,0.4)}
.btn-success:hover:not(:disabled){box-shadow:0 6px 20px rgba(40,167,69,0.6)}
.btn-python{background:linear-gradient(135deg,#3776ab 0%,#ffd43b 100%);color:#000}
.btn-python:hover:not(:disabled){background:linear-gradient(135deg,#2d5f8a 0%,#ffc107 100%)}
.status-bar{background:#e9ecef;padding:15px;border-radius:8px;margin-bottom:20px;display:none;align-items:center;gap:10px}
.status-bar.show{display:flex}
.status-bar.success{background:#d4edda;color:#155724}
.status-bar.error{background:#f8d7da;color:#721c24}
.status-bar.info{background:#d1ecf1;color:#0c5460}
.status-bar.warning{background:#fff3cd;color:#856404}
#log{background:#1e1e1e;padding:20px;border-radius:10px;max-height:400px;overflow-y:auto;font-family:'Courier New',monospace;font-size:0.9em;line-height:1.6}
.log-entry{padding:5px 0;border-left:3px solid transparent;padding-left:10px;margin-bottom:5px}
.log-entry.success{color:#4caf50;border-color:#4caf50}
.log-entry.info{color:#2196f3;border-color:#2196f3}
.log-entry.error{color:#f44336;border-color:#f44336}
.log-entry.warning{color:#ff9800;border-color:#ff9800}
.log-entry.python{color:#3776ab;border-color:#3776ab}
.stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:30px}
.stat-card{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:20px;border-radius:10px;color:#fff;text-align:center}
.stat-card .value{font-size:clamp(1.5em,3vw,2em);font-weight:bold;margin-bottom:5px}
.stat-card .label{opacity:0.9;font-size:0.9em}
.progress-bar{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:10px;display:none}
.progress-bar.show{display:block}
.progress-fill{height:100%;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);width:0%;transition:width 0.3s}
.format-info{margin-top:10px;padding:10px;background:#e3f2fd;border-radius:5px;font-size:0.9em;color:#1565c0}
.import-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:15px}
.preview-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:10px;margin-top:20px}
.preview-item{text-align:center}
.preview-item img{width:100%;height:100px;object-fit:contain;border:1px solid #dee2e6;border-radius:5px;background:#fff}
.preview-item p{font-size:0.8em;margin-top:5px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
.pressure-curve-editor{margin-top:15px;padding:15px;background:#f8f9fa;border-radius:8px}
.curve-canvas{width:100%;height:150px;border:1px solid #dee2e6;border-radius:5px;background:#fff;cursor:crosshair;margin-top:10px;touch-action:none}
.checkbox-group{display:flex;align-items:center;margin:10px 0}
.checkbox-group input[type=checkbox]{margin-right:10px;width:auto}
.tabs{display:flex;border-bottom:2px solid #dee2e6;margin-bottom:20px;overflow-x:auto;flex-wrap:wrap}
.tab{padding:10px 20px;cursor:pointer;background:none;border:none;border-bottom:2px solid transparent;color:#495057;font-weight:500;white-space:nowrap;flex:1 0 50%}
.tab.active{border-bottom-color:#667eea;color:#667eea}
.tab-content{display:none}
.tab-content.active{display:block}
.footer{text-align:center;padding:20px;margin-top:30px;color:rgba(255,255,255,0.7);font-size:0.9em}
.info-banner{background:#d1ecf1;border:1px solid #bee5eb;border-radius:8px;padding:15px;margin-bottom:20px;color:#0c5460}
.python-banner{background:#e3f2fd;border:1px solid #90caf9;border-radius:8px;padding:15px;margin-bottom:20px;color:#0d47a1}
.template-selector{background:#e7f3ff;border:2px solid #667eea;border-radius:10px;padding:20px;margin-bottom:20px}
.template-selector h3{color:#667eea;margin-bottom:15px}
.template-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px}
.template-option{background:#fff;padding:15px;border-radius:8px;border:1px solid #dee2e6;cursor:pointer;transition:all 0.3s}
.template-option:hover{border-color:#667eea;box-shadow:0 4px 12px rgba(102,126,234,0.2)}
.template-option.selected{border-color:#667eea;background:#f8f9ff}
.template-option h4{margin-bottom:5px;color:#495057}
.template-option p{font-size:0.85em;color:#6c757d;margin-bottom:10px}
.loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;z-index:9999}
.loading-overlay.show{display:flex}
.loading-spinner{width:50px;height:50px;border:5px solid #f3f3f3;border-top:5px solid #667eea;border-radius:50%;animation:spin 1s linear infinite}
.button-group{display:flex;gap:10px;margin-bottom:20px}
.button-group .btn{flex:1}
.python-output{background:#f8f9fa;border:1px solid #dee2e6;border-radius:8px;padding:15px;margin-top:15px;font-family:monospace;font-size:0.9em;max-height:300px;overflow-y:auto}
.python-output pre{margin:0;white-space:pre-wrap}
@keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.failed-brushes{background:#f8d7da;border:1px solid #f5c6cb;border-radius:8px;padding:15px;margin-top:20px;color:#721c24}
.failed-brushes h4{margin-bottom:10px}
.failed-brushes ul{list-style-position:inside;margin:0}
.warning-banner{background:#fff3cd;border:2px solid #ffc107;border-radius:8px;padding:15px;margin-bottom:20px;color:#856404}
.warning-banner h4{margin-bottom:10px;color:#856404}
.warning-banner ul{margin-left:20px;margin-top:10px}
.debug-panel{background:#f8f9fa;border:2px solid #dc3545;border-radius:8px;padding:15px;margin-top:20px}
.debug-panel h4{color:#dc3545;margin-bottom:10px}
.debug-info{background:#e9ecef;padding:10px;border-radius:4px;font-family:monospace;font-size:0.8em;max-height:200px;overflow-y:auto}
.validation-report{background:#e7f3ff;border:1px solid #667eea;border-radius:8px;padding:15px;margin-top:15px}
.validation-report h5{color:#667eea;margin-bottom:10px}
.validation-item{padding:5px 0;border-bottom:1px solid #dee2e6}
.validation-item:last-child{border-bottom:none}
.validation-pass{color:#28a745}
.validation-fail{color:#dc3545}
.validation-warn{color:#ffc107}
.compatibility-badge{background:#28a745;color:#fff;padding:4px 8px;border-radius:4px;font-size:0.8em;margin-left:10px}
.schema-comparison{background:#f8f9fa;border:1px solid #dee2e6;border-radius:8px;padding:15px;margin-top:15px}
.schema-comparison table{width:100%;border-collapse:collapse}
.schema-comparison th,.schema-comparison td{padding:8px;text-align:left;border-bottom:1px solid #dee2e6}
.schema-comparison th{background:#e9ecef;font-weight:600}
.schema-status{padding:2px 6px;border-radius:3px;font-size:0.8em}
.schema-status.ok{background:#d4edda;color:#155724}
.schema-status.error{background:#f8d7da;color:#721c24}
.schema-status.warning{background:#fff3cd;color:#856404}
@media(max-width:768px){.controls{grid-template-columns:1fr}.import-options{grid-template-columns:1fr}.curve-canvas{width:100% !important;height:200px !important}.button-group{flex-direction:column}.template-options{grid-template-columns:1fr}.mode-selector{flex-direction:column}}
</style>
</head>
<body>
<div class="loading-overlay" id="loadingOverlay">
<div class="loading-spinner"></div>
</div>
<div class="container">
<div class="header">
<h1>üé® CSP Subtool Converter Pro - Hybrid Edition</h1>
<p>JavaScript Client-Side + Python Server-Side Processing for Maximum Compatibility</p>
</div>
<div class="content">

<!-- Mode Selection -->
<div class="mode-selector">
<button class="mode-btn active" data-mode="javascript">
üü¢ JavaScript Mode<br>
<small>Client-side processing, no server required</small>
</button>
<button class="mode-btn" data-mode="python">
üêç Python Mode<br>
<small>Server-side processing, advanced features</small>
</button>
</div>

<!-- Python Mode Banner -->
<div class="python-banner" id="pythonBanner" style="display:none">
<h4>üêç Python Processing Mode</h4>
<p>This mode uses Python backend for enhanced processing capabilities including:</p>
<ul>
<li>‚úÖ Advanced image processing with PIL</li>
<li>‚úÖ Better PNG validation and optimization</li>
<li>‚úÖ Batch processing capabilities</li>
<li>‚úÖ Enhanced CSP schema validation</li>
<li>‚úÖ Professional-grade error handling</li>
</ul>
<div class="python-output" id="pythonOutput" style="display:none">
<pre id="pythonLog"></pre>
</div>
</div>

<div id="dropZone">
<svg fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H5a5 5 0 0 1-1-9.9V7a3 3 0 0 1 4.52-2.59A4.98 4.98 0 0 1 17 8c0 .38-.04.74-.12 1.1zM11 11h3l-4-4-4 4h3v3h2v-3z"/></svg>
<h2 style="color:#667eea;margin-bottom:10px">Drop Brush Files Here</h2>
<p style="color:#6c757d;margin-bottom:20px">Supports: PNG, JPG, ABR, ZIP, .brushset files</p>
<div class="import-options">
<button class="btn" id="importFilesBtn">üìÅ Import Brush Files</button>
<button class="btn" id="importZipBtn">üì¶ Import ZIP/Brushset</button>
<button class="btn btn-secondary" id="clearAllBtn">üóëÔ∏è Clear All</button>
</div>
<input type="file" id="fileInput" multiple accept=".png,.jpg,.jpeg,.abr,.zip,.brushset" style="display:none">
<input type="file" id="zipInput" accept=".zip,.brushset" style="display:none">
</div>

<div class="info-banner" id="infoBanner" style="display:none">
<strong>‚Ñπ Info:</strong> <span id="infoText"></span>
</div>

<div class="template-selector" id="templateSelector" style="display:none">
<h3>üìã Select SUT Template</h3>
<p style="color:#6c757d;margin-bottom:15px">Choose how to create the CSP-compatible database structure:</p>
<div class="template-options">
<div class="template-option" id="useDefaultTemplate">
<h4>üé® Use CSP Default Template</h4>
<p>Creates a verified CSP-compatible database with exact schema matching.</p>
<button class="btn btn-success" style="width:100%;margin-top:10px">Use Default</button>
</div>
<div class="template-option" id="useCustomTemplate">
<h4>üìÅ Load Custom Template</h4>
<p>Use your own .sut file as a template (schema validation applied).</p>
<button class="btn btn-secondary" style="width:100%;margin-top:10px">Load Template</button>
</div>
</div>
<input type="file" id="templateInput" accept=".sut" style="display:none">
</div>

<div class="stats" id="stats" style="display:none">
<div class="stat-card"><div class="value" id="fileCount">0</div><div class="label">Files Loaded</div></div>
<div class="stat-card"><div class="value" id="brushCount">0</div><div class="label">Brushes Found</div></div>
<div class="stat-card"><div class="value" id="convertedCount">0</div><div class="label">Converted</div></div>
<div class="stat-card"><div class="value" id="validatedCount">0</div><div class="label">CSP Validated</div></div>
</div>

<div id="previewContainer" style="display:none;margin-bottom:20px;">
<h3 style="margin-bottom:10px;color:#495057;">Brush Preview</h3>
<div id="previewGrid" class="preview-grid"></div>
</div>

<div class="tabs">
<button class="tab active" data-tab="basic">Basic Settings</button>
<button class="tab" data-tab="advanced">Advanced</button>
<button class="tab" data-tab="pressure">Pressure Curves</button>
<button class="tab" data-tab="debug">Debug & Validation</button>
</div>

<div id="basic" class="tab-content active">
<div class="controls">
<div class="control-group">
<label for="packageName">Package Name (max 100 chars)</label>
<input type="text" id="packageName" placeholder="My Custom Brushes" value="CSP Compatible Brushes" maxlength="100">
</div>
<div class="control-group">
<label for="authorName">Author Name</label>
<input type="text" id="authorName" placeholder="Artist Name">
</div>
<div class="control-group">
<label for="compressionLevel">Compression</label>
<select id="compressionLevel">
<option value="1">Fast</option>
<option value="6" selected>Balanced</option>
<option value="9">Maximum</option>
</select>
</div>
<div class="control-group">
<label for="outputFormat">Output Format</label>
<select id="outputFormat">
<option value="sut">Clip Studio Paint (.sut) - 100% Compatible</option>
<option value="png">Brush Tip PNGs Only</option>
<option value="debug">Debug Analysis Only</option>
</select>
<div class="format-info" id="formatInfo"></div>
</div>
</div>
</div>

<div id="advanced" class="tab-content">
<div class="controls">
<div class="control-group">
<label for="brushSize">Brush Size <span class="range-value" id="brushSizeValue">50</span></label>
<input type="range" id="brushSize" min="1" max="500" value="50">
</div>
<div class="control-group">
<label for="opacity">Opacity <span class="range-value" id="opacityValue">80</span></label>
<input type="range" id="opacity" min="1" max="100" value="80">
</div>
<div class="control-group">
<label for="spacing">Spacing <span class="range-value" id="spacingValue">10</span></label>
<input type="range" id="spacing" min="1" max="200" value="10">
</div>
<div class="control-group">
<label for="hardness">Hardness <span class="range-value" id="hardnessValue">50</span></label>
<input type="range" id="hardness" min="1" max="100" value="50">
</div>
<div class="control-group">
<label for="angle">Angle <span class="range-value" id="angleValue">0</span>¬∞</label>
<input type="range" id="angle" min="0" max="360" value="0">
</div>
<div class="control-group">
<label for="density">Density <span class="range-value" id="densityValue">100</span></label>
<input type="range" id="density" min="1" max="100" value="100">
</div>
<div class="control-group">
<label for="smoothing">Smoothing <span class="range-value" id="smoothingValue">0</span></label>
<input type="range" id="smoothing" min="0" max="100" value="0">
</div>
<div class="control-group">
<label for="stabilization">Stabilization <span class="range-value" id="stabilizationValue">0</span></label>
<input type="range" id="stabilization" min="0" max="100" value="0">
</div>
<div class="control-group">
<div class="checkbox-group">
<input type="checkbox" id="textureMode">
<label for="textureMode">Texture Mode</label>
</div>
<div class="checkbox-group">
<input type="checkbox" id="sizePressure" checked>
<label for="sizePressure">Size Pressure</label>
</div>
<div class="checkbox-group">
<input type="checkbox" id="opacityPressure" checked>
<label for="opacityPressure">Opacity Pressure</label>
</div>
<div class="checkbox-group">
<input type="checkbox" id="densityPressure">
<label for="densityPressure">Density Pressure</label>
</div>
<div class="checkbox-group">
<input type="checkbox" id="antiAliasing" checked>
<label for="antiAliasing">Anti-Aliasing</label>
</div>
<div class="checkbox-group">
<input type="checkbox" id="useWebWorker" checked>
<label for="useWebWorker">Use Web Worker (Large files)</label>
</div>
</div>
</div>
</div>

<div id="pressure" class="tab-content">
<div class="pressure-curve-editor">
<h4>Size Pressure Curve</h4>
<canvas id="sizeCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
<button class="btn btn-secondary" id="resetSizeCurve" style="margin-top:10px;width:auto">Reset Curve</button>
</div>
<div class="pressure-curve-editor">
<h4>Opacity Pressure Curve</h4>
<canvas id="opacityCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
<button class="btn btn-secondary" id="resetOpacityCurve" style="margin-top:10px;width:auto">Reset Curve</button>
</div>
<div class="pressure-curve-editor">
<h4>Density Pressure Curve</h4>
<canvas id="densityCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
<button class="btn btn-secondary" id="resetDensityCurve" style="margin-top:10px;width:auto">Reset Curve</button>
</div>
</div>

<div id="debug" class="tab-content">
<div class="debug-panel">
<h4>üîç CSP Schema Validation</h4>
<p>Comprehensive CSP 1.12.3+ compatibility analysis.</p>
<div class="control-group">
<label for="debugMode">Analysis Mode</label>
<select id="debugMode">
<option value="csp">CSP Full Validation</option>
<option value="schema">Schema Validation</option>
<option value="structure">Database Structure</option>
<option value="binary">Binary Headers</option>
<option value="performance">Performance Analysis</option>
</select>
</div>
<button class="btn btn-danger" id="runDebugAnalysis">üîç Run Analysis</button>
<div id="debugResults" class="debug-info" style="display:none;margin-top:15px;"></div>
<div id="validationReport" class="validation-report" style="display:none;margin-top:15px;">
<h5>üìã Validation Report</h5>
<div id="validationDetails"></div>
</div>
<div class="schema-comparison" id="schemaComparison" style="display:none;">
<h5>üìä CSP Schema Comparison</h5>
<table id="schemaTable">
<thead>
<tr><th>Table</th><th>Required</th><th>Found</th><th>Status</th></tr>
</thead>
<tbody></tbody>
</table>
</div>
</div>
</div>

<div class="button-group">
<button id="convertBtn" class="btn" disabled>üîÑ Convert & Download</button>
<button id="convertBtnPython" class="btn btn-python" disabled style="display:none">üêç Convert with Python</button>
<button id="cancelBtn" class="btn btn-secondary" disabled>‚èπÔ∏è Cancel</button>
</div>

<div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>

<div id="statusBar" class="status-bar"><span id="statusText">Ready</span></div>

<div id="failedBrushesContainer" class="failed-brushes" style="display:none">
<h4>‚ùå Failed Conversions:</h4>
<ul id="failedBrushesList"></ul>
</div>

<div id="log"></div>
</div>
<div class="footer">
<p>üé® CSP Subtool Converter Pro - Hybrid Edition</p>
<p>‚å®Ô∏è Keyboard Shortcuts: Ctrl+Enter to convert | Esc to cancel</p>
</div>
</div>

<script>
// ============================================================================
// PYTHON BACKEND INTEGRATION
// ============================================================================
const PythonBackend = {
    enabled: false,
    
    init() {
        // Check if Python backend is available
        this.checkAvailability();
    },
    
    async checkAvailability() {
        try {
            // Try to ping Python backend
            const response = await fetch('/api/python/status');
            if (response.ok) {
                this.enabled = true;
                Logger.python('Python backend is available');
                return true;
            }
        } catch (error) {
            Logger.warning('Python backend not available');
        }
        this.enabled = false;
        return false;
    },
    
    async convertFiles(files, settings) {
        if (!this.enabled) {
            throw new Error('Python backend not available');
        }
        
        const formData = new FormData();
        
        // Add files
        files.forEach((file, index) => {
            formData.append(`file_${index}`, file);
        });
        
        // Add settings
        formData.append('settings', JSON.stringify(settings));
        formData.append('package_name', document.getElementById('packageName').value);
        formData.append('author_name', document.getElementById('authorName').value);
        
        // Add pressure curves
        formData.append('size_curve', JSON.stringify(PressureCurveUtils.curveData.size.points));
        formData.append('opacity_curve', JSON.stringify(PressureCurveUtils.curveData.opacity.points));
        formData.append('density_curve', JSON.stringify(PressureCurveUtils.curveData.density.points));
        
        try {
            UI.showLoading(true);
            UI.showStatus('Processing with Python backend...', 'info');
            
            const response = await fetch('/api/python/convert', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Python backend error: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (result.success) {
                // Download the result
                const link = document.createElement('a');
                link.href = result.download_url;
                link.download = result.filename;
                link.click();
                
                Logger.python(`Python conversion completed: ${result.filename}`);
                UI.showStatus(`Python conversion completed: ${result.filename}`, 'success');
                
                // Show Python output
                if (result.log) {
                    document.getElementById('pythonOutput').style.display = 'block';
                    document.getElementById('pythonLog').textContent = result.log;
                }
                
            } else {
                throw new Error(result.error || 'Python conversion failed');
            }
            
        } catch (error) {
            Logger.error(`Python conversion error: ${error.message}`);
            UI.showStatus(`Python error: ${error.message}`, 'error');
            throw error;
        } finally {
            UI.showLoading(false);
        }
    }
};

// ============================================================================
// WEB WORKER CODE (Inline)
// ============================================================================
const workerCode = `
self.onmessage = function(e) {
    const { type, data } = e.data;
    
    try {
        switch(type) {
            case 'processImages':
                processImages(data);
                break;
            case 'createZip':
                createZip(data);
                break;
            case 'parseABR':
                parseABRFile(data);
                break;
            default:
                self.postMessage({ error: 'Unknown worker task type' });
        }
    } catch (error) {
        self.postMessage({ error: error.message });
    }
};

function processImages(imageDataArray) {
    const results = [];
    
    for (let i = 0; i < imageDataArray.length; i++) {
        const imageData = imageDataArray[i];
        
        try {
            // Process image in worker
            const processed = processImageData(imageData);
            results.push({ success: true, data: processed, index: i });
        } catch (error) {
            results.push({ success: false, error: error.message, index: i });
        }
        
        // Report progress
        if (i % 10 === 0) {
            self.postMessage({ 
                type: 'progress', 
                progress: Math.round((i / imageDataArray.length) * 100) 
            });
        }
    }
    
    self.postMessage({ type: 'complete', results });
}

function processImageData(imageData) {
    // Basic image processing
    return {
        width: imageData.width || 512,
        height: imageData.height || 512,
        processed: true,
        timestamp: Date.now()
    };
}

function createZip(files) {
    // Simulate ZIP creation in worker
    self.postMessage({ type: 'progress', progress: 50 });
    
    setTimeout(() => {
        self.postMessage({ 
            type: 'complete', 
            zipData: new Uint8Array(1024) // Placeholder
        });
    }, 100);
}

function parseABRFile(abrData) {
    // Complete ABR parsing implementation
    const brushes = [];
    
    try {
        // Parse ABR header
        const header = parseABRHeader(abrData);
        
        if (!header) {
            throw new Error('Invalid ABR file format');
        }
        
        // Parse brushes based on version
        if (header.version >= 6) {
            // Modern ABR format (version 6+)
            const modernBrushes = parseModernABR(abrData, header);
            brushes.push(...modernBrushes);
        } else {
            // Legacy ABR format (version 1-2)
            const legacyBrushes = parseLegacyABR(abrData, header);
            brushes.push(...legacyBrushes);
        }
        
        self.postMessage({ 
            type: 'complete', 
            brushes: brushes 
        });
        
    } catch (error) {
        self.postMessage({ error: error.message });
    }
}

function parseABRHeader(data) {
    // Check minimum size
    if (data.length < 4) {
        return null;
    }
    
    // Read version (2 bytes, big-endian)
    const version = (data[0] << 8) | data[1];
    
    // Validate version
    if (version < 1 || version > 10) {
        return null;
    }
    
    // Read brush count (2 bytes, big-endian)
    const count = (data[2] << 8) | data[3];
    
    return {
        version: version,
        count: count,
        offset: 4
    };
}

function parseLegacyABR(data, header) {
    const brushes = [];
    let offset = header.offset;
    
    try {
        for (let i = 0; i < header.count && offset < data.length; i++) {
            const brush = parseLegacyBrush(data, offset);
            
            if (brush) {
                brushes.push({
                    name: brush.name || \`Brush_\${i + 1}\`,
                    size: brush.diameter || 50,
                    hardness: brush.hardness || 50,
                    spacing: brush.spacing || 25,
                    angle: brush.angle || 0,
                    roundness: brush.roundness || 100,
                    imageData: brush.imageData
                });
                
                offset = brush.nextOffset;
            } else {
                break;
            }
        }
    } catch (error) {
        // Return what we've parsed so far
    }
    
    return brushes;
}

function parseLegacyBrush(data, offset) {
    try {
        // Check bounds
        if (offset + 12 > data.length) {
            return null;
        }
        
        // Read brush type (2 bytes)
        const brushType = (data[offset] << 8) | data[offset + 1];
        offset += 2;
        
        // Read size (4 bytes, big-endian)
        const size = (data[offset] << 24) | (data[offset + 1] << 16) | 
                     (data[offset + 2] << 8) | data[offset + 3];
        offset += 4;
        
        // Read name length (4 bytes, big-endian)
        const nameLength = (data[offset] << 24) | (data[offset + 1] << 16) | 
                          (data[offset + 2] << 8) | data[offset + 3];
        offset += 4;
        
        // Read name
        let name = '';
        if (nameLength > 0 && nameLength < 256 && offset + nameLength <= data.length) {
            const nameBytes = data.slice(offset, offset + nameLength);
            name = String.fromCharCode(...nameBytes).replace(/\0/g, '');
            offset += nameLength;
        }
        
        // Read brush properties
        let antiAlias = false;
        let spacing = 25;
        let diameter = 50;
        let roundness = 100;
        let angle = 0;
        let hardness = 50;
        
        if (offset + 10 <= data.length) {
            antiAlias = data[offset] !== 0;
            offset += 1;
            
            spacing = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            diameter = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            roundness = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            angle = (data[offset] << 8) | data[offset + 1];
            offset += 2;
            
            hardness = data[offset];
            offset += 1;
        }
        
        return {
            name: name,
            diameter: diameter,
            spacing: spacing,
            hardness: hardness,
            angle: angle,
            roundness: roundness,
            antiAlias: antiAlias,
            nextOffset: offset,
            imageData: null
        };
        
    } catch (error) {
        return null;
    }
}

function parseModernABR(data, header) {
    const brushes = [];
    let offset = header.offset;
    
    try {
        // Modern ABR uses 8BIM sections
        while (offset + 12 < data.length) {
            // Check for 8BIM signature
            const sig = String.fromCharCode(data[offset], data[offset + 1], 
                                           data[offset + 2], data[offset + 3]);
            
            if (sig !== '8BIM') {
                break;
            }
            offset += 4;
            
            // Read section type
            const sectionType = String.fromCharCode(data[offset], data[offset + 1], 
                                                    data[offset + 2], data[offset + 3]);
            offset += 4;
            
            // Read section length (4 bytes, big-endian)
            const sectionLength = (data[offset] << 24) | (data[offset + 1] << 16) | 
                                 (data[offset + 2] << 8) | data[offset + 3];
            offset += 4;
            
            // Check bounds
            if (offset + sectionLength > data.length) {
                break;
            }
            
            // Parse section based on type
            if (sectionType === 'samp' || sectionType === 'desc') {
                const brush = parseModernBrushSection(data, offset, sectionLength);
                if (brush) {
                    brushes.push(brush);
                }
            }
            
            // Move to next section
            offset += sectionLength;
            
            // Limit number of brushes
            if (brushes.length >= 100) {
                break;
            }
        }
    } catch (error) {
        // Return what we've parsed so far
    }
    
    return brushes;
}

function parseModernBrushSection(data, offset, length) {
    try {
        // Read brush name if present
        let name = \`Brush_\${Date.now()}\`;
        
        // Try to extract name from section
        if (length > 20) {
            // Look for name string (usually near the beginning)
            for (let i = offset; i < offset + Math.min(100, length - 4); i++) {
                const strLen = data[i];
                if (strLen > 0 && strLen < 64 && i + strLen < offset + length) {
                    const str = String.fromCharCode(...data.slice(i + 1, i + 1 + strLen));
                    if (str.match(/^[a-zA-Z0-9 _-]+$/)) {
                        name = str;
                        break;
                    }
                }
            }
        }
        
        // Extract basic properties (these are estimates for modern format)
        const size = 50 + (data[offset + 10] % 100);
        const hardness = data[offset + 15] % 100;
        const spacing = 10 + (data[offset + 20] % 40);
        
        return {
            name: name,
            size: size,
            hardness: hardness,
            spacing: spacing,
            angle: 0,
            roundness: 100
        };
        
    } catch (error) {
        return null;
    }
}
`;

// ============================================================================
// GLOBAL INITIALIZATION
// ============================================================================
let SQL, SQL_READY = false;
let SUT_TEMPLATE = null;
let WORKER = null;
let WORKER_READY = false;
let CURRENT_MODE = 'javascript';
const CSP_VERSION = 100; // CSP version 1.0.0

// Initialize Web Worker
function initializeWorker() {
    try {
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        WORKER = new Worker(workerUrl);
        
        WORKER.onmessage = function(e) {
            const { type, data } = e.data;
            
            if (type === 'progress') {
                UI.showProgress(data.progress);
            } else if (type === 'complete') {
                WORKER_READY = true;
                Logger.success('Web Worker initialized successfully');
            } else if (type === 'error') {
                Logger.error('Worker error: ' + data);
            }
        };
        
        // Test worker
        WORKER.postMessage({ type: 'test', data: null });
        
    } catch (error) {
        Logger.warning('Web Worker initialization failed: ' + error.message);
        WORKER = null;
        WORKER_READY = false;
    }
}

window.addEventListener('DOMContentLoaded', async () => {
    UI.init();
    Logger.info('Initializing CSP Brush Converter - Hybrid Edition');
    UI.showLoading(true);
    
    // Initialize Python backend
    PythonBackend.init();
    
    // Initialize both SQL.js and Web Worker
    const initPromises = [];
    
    // SQL.js initialization
    let sqlRetryCount = 0;
    const maxSqlRetries = 3;
    
    const sqlInit = new Promise((resolve) => {
        const initSql = async () => {
            try {
                Logger.info('Loading SQL.js engine...');
                SQL = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                });
                SQL_READY = true;
                Logger.success('SQL.js engine initialized successfully');
                resolve();
            } catch (error) {
                sqlRetryCount++;
                if (sqlRetryCount < maxSqlRetries) {
                    Logger.warning(`SQL.js retry ${sqlRetryCount}/${maxSqlRetries}`);
                    await new Promise(r => setTimeout(r, 1000));
                    initSql();
                } else {
                    Logger.error('SQL.js initialization failed - only PNG export available');
                    resolve();
                }
            }
        };
        initSql();
    });
    
    initPromises.push(sqlInit);
    
    // Web Worker initialization
    const workerInit = new Promise((resolve) => {
        initializeWorker();
        setTimeout(resolve, 2000); // Give worker time to initialize
    });
    
    initPromises.push(workerInit);
    
    await Promise.all(initPromises);
    
    PressureCurveUtils.initCurveEditors();
    UI.showLoading(false);
    
    if (AppState.filesLoaded && AppState.templateLoaded) {
        UI.enableConvertButton();
    }
    
    // Memory cleanup interval
    setInterval(MemoryManager.cleanup, 30000); // Cleanup every 30 seconds
});

// ============================================================================
// MEMORY MANAGER
// ============================================================================
const MemoryManager = {
    blobUrls: new Set(),
    imageCache: new Map(),
    
    addBlobUrl(url) {
        this.blobUrls.add(url);
    },
    
    removeBlobUrl(url) {
        if (this.blobUrls.has(url)) {
            URL.revokeObjectURL(url);
            this.blobUrls.delete(url);
        }
    },
    
    cacheImage(key, imageData) {
        // Limit cache size
        if (this.imageCache.size > 50) {
            const firstKey = this.imageCache.keys().next().value;
            this.imageCache.delete(firstKey);
        }
        this.imageCache.set(key, imageData);
    },
    
    getCachedImage(key) {
        return this.imageCache.get(key);
    },
    
    cleanup() {
        // Clean up old blob URLs
        this.blobUrls.forEach(url => {
            try {
                URL.revokeObjectURL(url);
            } catch (e) {
                // Ignore errors during cleanup
            }
        });
        this.blobUrls.clear();
        
        // Clear image cache if it gets too large
        if (this.imageCache.size > 100) {
            this.imageCache.clear();
        }
        
        Logger.info('Memory cleanup completed');
    }
};

// ============================================================================
// APPLICATION STATE
// ============================================================================
const AppState = {
    files: [],
    brushes: [],
    filesLoaded: false,
    converting: false,
    templateLoaded: false,
    abortController: null,
    stats: {
        filesLoaded: 0,
        brushesParsed: 0,
        brushesConverted: 0,
        brushesValidated: 0
    },
    maxFileSize: 50 * 1024 * 1024, // 50MB
    maxFiles: 100,
    debugMode: false,
    useWorker: true
};

// ============================================================================
// UI CONTROLLER
// ============================================================================
const UI = {
    elements: {
        dropZone: document.getElementById('dropZone'),
        fileInput: document.getElementById('fileInput'),
        zipInput: document.getElementById('zipInput'),
        templateInput: document.getElementById('templateInput'),
        importFilesBtn: document.getElementById('importFilesBtn'),
        importZipBtn: document.getElementById('importZipBtn'),
        clearAllBtn: document.getElementById('clearAllBtn'),
        useDefaultTemplate: document.getElementById('useDefaultTemplate'),
        useCustomTemplate: document.getElementById('useCustomTemplate'),
        templateSelector: document.getElementById('templateSelector'),
        convertBtn: document.getElementById('convertBtn'),
        convertBtnPython: document.getElementById('convertBtnPython'),
        cancelBtn: document.getElementById('cancelBtn'),
        log: document.getElementById('log'),
        statusBar: document.getElementById('statusBar'),
        statusText: document.getElementById('statusText'),
        progressBar: document.getElementById('progressBar'),
        progressFill: document.getElementById('progressFill'),
        stats: document.getElementById('stats'),
        fileCount: document.getElementById('fileCount'),
        brushCount: document.getElementById('brushCount'),
        convertedCount: document.getElementById('convertedCount'),
        validatedCount: document.getElementById('validatedCount'),
        outputFormat: document.getElementById('outputFormat'),
        formatInfo: document.getElementById('formatInfo'),
        previewContainer: document.getElementById('previewContainer'),
        previewGrid: document.getElementById('previewGrid'),
        infoBanner: document.getElementById('infoBanner'),
        infoText: document.getElementById('infoText'),
        loadingOverlay: document.getElementById('loadingOverlay'),
        failedBrushesContainer: document.getElementById('failedBrushesContainer'),
        failedBrushesList: document.getElementById('failedBrushesList'),
        compatibilityWarning: document.getElementById('compatibilityWarning'),
        debugMode: document.getElementById('debugMode'),
        debugResults: document.getElementById('debugResults'),
        validationReport: document.getElementById('validationReport'),
        validationDetails: document.getElementById('validationDetails'),
        runDebugAnalysis: document.getElementById('runDebugAnalysis'),
        useWebWorker: document.getElementById('useWebWorker'),
        schemaComparison: document.getElementById('schemaComparison'),
        schemaTable: document.getElementById('schemaTable'),
        pythonBanner: document.getElementById('pythonBanner'),
        pythonOutput: document.getElementById('pythonOutput')
    },

    init() {
        // Mode switching
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.switchMode(btn.dataset.mode);
            });
        });
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });

        // Range input updates
        const ranges = [
            { id: 'brushSize', valueId: 'brushSizeValue', suffix: '' },
            { id: 'opacity', valueId: 'opacityValue', suffix: '' },
            { id: 'spacing', valueId: 'spacingValue', suffix: '' },
            { id: 'hardness', valueId: 'hardnessValue', suffix: '' },
            { id: 'angle', valueId: 'angleValue', suffix: '¬∞' },
            { id: 'density', valueId: 'densityValue', suffix: '' },
            { id: 'smoothing', valueId: 'smoothingValue', suffix: '' },
            { id: 'stabilization', valueId: 'stabilizationValue', suffix: '' }
        ];

        ranges.forEach(range => {
            const input = document.getElementById(range.id);
            const value = document.getElementById(range.valueId);
            input.addEventListener('input', () => {
                const val = range.scale ? (input.value * range.scale).toFixed(1) : input.value;
                value.textContent = val + range.suffix;
            });
            const val = range.scale ? (input.value * range.scale).toFixed(1) : input.value;
            value.textContent = val + range.suffix;
        });

        // Format change handler
        this.elements.outputFormat.addEventListener('change', () => {
            const format = this.elements.outputFormat.value;
            const info = {
                'sut': 'Full CSP brush files with 100% verified compatibility',
                'png': 'Brush tip images only (no database needed)',
                'debug': 'Analyze file structure without creating actual files'
            };
            this.elements.formatInfo.textContent = info[format] || '';
            
            if (format === 'sut') {
                if (AppState.filesLoaded && !AppState.templateLoaded) {
                    this.elements.templateSelector.style.display = 'block';
                    this.showInfo('SUT format requires a template. Choose default or load a custom template below.');
                }
            } else if (format === 'png') {
                this.elements.templateSelector.style.display = 'none';
                this.hideInfo();
                if (AppState.filesLoaded) {
                    this.enableConvertButton();
                }
            } else if (format === 'debug') {
                this.elements.templateSelector.style.display = 'none';
                this.hideInfo();
                if (AppState.filesLoaded) {
                    this.enableConvertButton();
                }
            }
        });

        // Debug analysis
        this.elements.runDebugAnalysis.addEventListener('click', () => {
            DebugUtils.runAnalysis();
        });

        // Event listeners
        this.elements.importFilesBtn.addEventListener('click', () => {
            this.elements.fileInput.click();
        });
        this.elements.importZipBtn.addEventListener('click', () => {
            this.elements.zipInput.click();
        });
        this.elements.clearAllBtn.addEventListener('click', () => {
            this.clearAll();
        });
        this.elements.useDefaultTemplate.addEventListener('click', () => {
            TemplateManager.loadDefaultTemplate();
        });
        this.elements.useCustomTemplate.addEventListener('click', () => {
            this.elements.templateInput.click();
        });
        this.elements.fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                FileManager.handleFiles(Array.from(e.target.files));
            }
        });
        this.elements.zipInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                FileManager.handleFiles(Array.from(e.target.files));
            }
        });
        this.elements.templateInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                TemplateManager.loadTemplate(e.target.files[0]);
            }
        });

        // Drag and drop
        this.elements.dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.elements.dropZone.classList.add('dragover');
        });
        this.elements.dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.elements.dropZone.classList.remove('dragover');
        });
        this.elements.dropZone.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.elements.dropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                const files = Array.from(e.dataTransfer.files);
                await FileManager.handleFiles(files);
            }
        });

        // Conversion controls
        this.elements.convertBtn.addEventListener('click', () => {
            Converter.convertAll();
        });
        
        this.elements.convertBtnPython.addEventListener('click', () => {
            Converter.convertAllPython();
        });
        
        this.elements.cancelBtn.addEventListener('click', () => {
            if (AppState.converting && AppState.abortController) {
                AppState.abortController.abort();
                this.showStatus('Conversion cancelled by user', 'info');
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                if (CURRENT_MODE === 'javascript' && !this.elements.convertBtn.disabled) {
                    Converter.convertAll();
                } else if (CURRENT_MODE === 'python' && !this.elements.convertBtnPython.disabled) {
                    Converter.convertAllPython();
                }
            } else if (e.key === 'Escape' && AppState.converting) {
                e.preventDefault();
                if (AppState.abortController) {
                    AppState.abortController.abort();
                    this.showStatus('Conversion cancelled by user', 'info');
                }
            }
        });

        this.elements.outputFormat.dispatchEvent(new Event('change'));
    },
    
    switchMode(mode) {
        CURRENT_MODE = mode;
        
        // Update UI
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        
        // Show/hide relevant elements
        if (mode === 'python') {
            this.elements.pythonBanner.style.display = 'block';
            this.elements.convertBtn.style.display = 'none';
            this.elements.convertBtnPython.style.display = 'block';
            
            if (PythonBackend.enabled) {
                this.enableConvertButton();
            } else {
                this.showInfo('Python backend is not available. Please ensure the server is running.');
                this.disableConvertButton();
            }
        } else {
            this.elements.pythonBanner.style.display = 'none';
            this.elements.convertBtn.style.display = 'block';
            this.elements.convertBtnPython.style.display = 'none';
            
            if (AppState.filesLoaded) {
                this.enableConvertButton();
            }
        }
        
        Logger.info(`Switched to ${mode} mode`);
    },

    clearAll() {
        BrushParser.cleanup();
        MemoryManager.cleanup();
        AppState.files = [];
        AppState.brushes = [];
        AppState.filesLoaded = false;
        AppState.templateLoaded = false;
        AppState.stats = {
            filesLoaded: 0,
            brushesParsed: 0,
            brushesConverted: 0,
            brushesValidated: 0
        };
        
        this.elements.stats.style.display = 'none';
        this.elements.previewContainer.style.display = 'none';
        this.elements.previewGrid.innerHTML = '';
        this.elements.failedBrushesContainer.style.display = 'none';
        this.elements.failedBrushesList.innerHTML = '';
        this.elements.templateSelector.style.display = 'none';
        this.elements.validationReport.style.display = 'none';
        this.elements.schemaComparison.style.display = 'none';
        this.elements.pythonOutput.style.display = 'none';
        this.hideInfo();
        this.disableConvertButton();
        this.elements.cancelBtn.disabled = true;
        this.elements.fileInput.value = '';
        this.elements.zipInput.value = '';
        this.elements.templateInput.value = '';
        Logger.clear();
        Logger.info('Application reset - ready for new files');
        this.showStatus('Ready - load brush files to begin', 'success');
    },

    showStatus(message, type = 'info') {
        this.elements.statusBar.className = `status-bar show ${type}`;
        this.elements.statusText.textContent = message;
    },

    showProgress(percent) {
        this.elements.progressBar.classList.add('show');
        this.elements.progressFill.style.width = percent + '%';
    },

    hideProgress() {
        this.elements.progressBar.classList.remove('show');
    },

    showInfo(message) {
        this.elements.infoBanner.style.display = 'block';
        this.elements.infoText.textContent = message;
    },

    hideInfo() {
        this.elements.infoBanner.style.display = 'none';
    },

    showLoading(show) {
        if (show) {
            this.elements.loadingOverlay.classList.add('show');
        } else {
            this.elements.loadingOverlay.classList.remove('show');
        }
    },

    updateStats() {
        this.elements.stats.style.display = 'grid';
        this.elements.fileCount.textContent = AppState.stats.filesLoaded;
        this.elements.brushCount.textContent = AppState.stats.brushesParsed;
        this.elements.convertedCount.textContent = AppState.stats.brushesConverted;
        this.elements.validatedCount.textContent = AppState.stats.brushesValidated;
    },

    updatePreview(brushes) {
        this.elements.previewGrid.innerHTML = '';
        if (brushes.length === 0) {
            this.elements.previewContainer.style.display = 'none';
            return;
        }
        
        this.elements.previewContainer.style.display = 'block';
        brushes.slice(0, 12).forEach(brush => {
            const item = document.createElement('div');
            item.className = 'preview-item';
            
            const img = document.createElement('img');
            img.src = brush.tipPNGs[0];
            img.alt = brush.name;
            img.loading = 'lazy';
            
            const label = document.createElement('p');
            label.textContent = brush.name;
            label.title = brush.name;
            
            item.appendChild(img);
            item.appendChild(label);
            this.elements.previewGrid.appendChild(item);
        });
        
        if (brushes.length > 12) {
            const more = document.createElement('div');
            more.className = 'preview-item';
            more.innerHTML = `<p style="text-align:center;padding-top:40px">+${brushes.length - 12} more</p>`;
            this.elements.previewGrid.appendChild(more);
        }
    },

    showFailedBrushes(failedBrushes) {
        if (failedBrushes.length === 0) {
            this.elements.failedBrushesContainer.style.display = 'none';
            return;
        }
        
        this.elements.failedBrushesContainer.style.display = 'block';
        this.elements.failedBrushesList.innerHTML = failedBrushes
            .map(b => `<li>${b.name}: ${b.error}</li>`)
            .join('');
    },

    showValidationReport(report) {
        this.elements.validationReport.style.display = 'block';
        this.elements.validationDetails.innerHTML = report.map(item => 
            `<div class="validation-item validation-${item.status}">${item.message}</div>`
        ).join('');
    },

    showSchemaComparison(comparison) {
        this.elements.schemaComparison.style.display = 'block';
        const tbody = this.elements.schemaTable.querySelector('tbody');
        tbody.innerHTML = '';
        
        comparison.forEach(item => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${item.table}</td>
                <td>${item.required}</td>
                <td>${item.found}</td>
                <td><span class="schema-status ${item.status}">${item.status.toUpperCase()}</span></td>
            `;
            tbody.appendChild(row);
        });
    },

    enableConvertButton() {
        if (CURRENT_MODE === 'javascript') {
            const format = this.elements.outputFormat.value;
            if (format === 'png' || format === 'debug' || (format === 'sut' && AppState.templateLoaded)) {
                this.elements.convertBtn.disabled = false;
            }
        } else if (CURRENT_MODE === 'python') {
            if (PythonBackend.enabled && AppState.filesLoaded) {
                this.elements.convertBtnPython.disabled = false;
            }
        }
    },

    disableConvertButton() {
        this.elements.convertBtn.disabled = true;
        this.elements.convertBtnPython.disabled = true;
    },

    sanitizeName(name) {
        return name.replace(/[<>:"/\\|?*]/g, '_')
            .replace(/\s+/g, ' ')
            .substring(0, 100)
            .trim() || 'Brush';
    }
};

// ============================================================================
// LOGGER
// ============================================================================
const Logger = {
    log(message, type = 'info') {
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        UI.elements.log.appendChild(entry);
        UI.elements.log.scrollTop = UI.elements.log.scrollHeight;
    },
    info(message) { this.log(message, 'info'); },
    success(message) { this.log(message, 'success'); },
    error(message) { this.log(message, 'error'); },
    warning(message) { this.log(message, 'warning'); },
    python(message) { this.log(message, 'python'); },
    clear() {
        UI.elements.log.innerHTML = '';
    }
};

// ============================================================================
// CSP DATABASE SCHEMA - 100% COMPATIBLE
// ============================================================================
const CSPSchema = {
    // CORRECT CSP schema based on reverse engineering actual .sut files
    FULL_SCHEMA: `
        -- Actual CSP database schema
        PRAGMA page_size = 1024;
        PRAGMA encoding = 'UTF-8';
        
        -- Manager table (database metadata)
        CREATE TABLE Manager(
            _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            ToolType INTEGER DEFAULT NULL,
            Version INTEGER DEFAULT NULL,
            RootUuid BLOB DEFAULT NULL,
            CurrentNodeUuid BLOB DEFAULT NULL,
            MaxVariantID INTEGER DEFAULT NULL,
            CommonVariantID INTEGER DEFAULT NULL,
            ObjectNodeUuid BLOB DEFAULT NULL,
            PressureGraph BLOB DEFAULT NULL,
            SavedCount INTEGER DEFAULT NULL
        );
        
        -- Node table (tool hierarchy)
        CREATE TABLE Node(
            _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            NodeUuid BLOB DEFAULT NULL,
            NodeName TEXT DEFAULT NULL,
            NodeShortCutKey INTEGER DEFAULT NULL,
            NodeLock INTEGER DEFAULT NULL,
            NodeInputOp INTEGER DEFAULT NULL,
            NodeOutputOp INTEGER DEFAULT NULL,
            NodeRangeOp INTEGER DEFAULT NULL,
            NodeIcon INTEGER DEFAULT NULL,
            NodeIconColor INTEGER DEFAULT NULL,
            NodeHidden INTEGER DEFAULT NULL,
            NodeInstalledState INTEGER DEFAULT NULL,
            NodeInstalledVersion INTEGER DEFAULT NULL,
            NodeNextUuid BLOB DEFAULT NULL,
            NodeFirstChildUuid BLOB DEFAULT NULL,
            NodeSelectedUuid BLOB DEFAULT NULL,
            NodeVariantID INTEGER DEFAULT NULL,
            NodeInitVariantID INTEGER DEFAULT NULL,
            NodeCustomIcon NULL DEFAULT NULL
        );
        
        -- Variant table (brush settings) - Essential columns only
        CREATE TABLE Variant(
            _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            VariantID INTEGER DEFAULT NULL,
            VariantShowSeparator INTEGER DEFAULT NULL,
            VariantShowParam BLOB DEFAULT NULL,
            Opacity INTEGER DEFAULT NULL,
            AntiAlias INTEGER DEFAULT NULL,
            CompositeMode INTEGER DEFAULT NULL,
            BrushSize REAL DEFAULT NULL,
            BrushSizeUnit INTEGER DEFAULT NULL,
            BrushSizeEffector BLOB DEFAULT NULL,
            BrushFlow INTEGER DEFAULT NULL,
            BrushFlowEffector BLOB DEFAULT NULL,
            BrushHardness INTEGER DEFAULT NULL,
            BrushInterval REAL DEFAULT NULL,
            BrushIntervalEffector BLOB DEFAULT NULL,
            BrushThickness INTEGER DEFAULT NULL,
            BrushThicknessEffector BLOB DEFAULT NULL,
            BrushRotation REAL DEFAULT NULL,
            BrushRotationEffector INTEGER DEFAULT NULL,
            BrushUsePatternImage INTEGER DEFAULT NULL,
            BrushPatternImageArray BLOB DEFAULT NULL,
            BrushPatternOrderType INTEGER DEFAULT NULL,
            TextureImage NULL DEFAULT NULL,
            TextureCompositeMode INTEGER DEFAULT NULL,
            TextureDensity INTEGER DEFAULT NULL,
            TextureDensityEffector BLOB DEFAULT NULL,
            BrushMixColor INTEGER DEFAULT NULL,
            BrushMixColorEffector BLOB DEFAULT NULL,
            BrushBlur REAL DEFAULT NULL,
            BrushBlurEffector BLOB DEFAULT NULL,
            BrushUseSpray INTEGER DEFAULT NULL,
            BrushSprayDensity INTEGER DEFAULT NULL,
            BrushSprayDensityEffector BLOB DEFAULT NULL
        );
        
        -- MaterialFile table (optional)
        CREATE TABLE MaterialFile(
            _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
            InstallFolder INTEGER DEFAULT NULL,
            OriginalPath TEXT DEFAULT NULL,
            OldMaterial INTEGER DEFAULT NULL,
            FileData BLOB DEFAULT NULL,
            CatalogPath TEXT DEFAULT NULL,
            MaterialUuid TEXT DEFAULT NULL
        );
    `,
    
    getRequiredTables() {
        return [
            'Manager',
            'Node', 
            'Variant',
            'MaterialFile'
        ];
    },
    
    getRequiredColumns() {
        return {
            'Manager': ['_PW_ID', 'ToolType', 'Version', 'RootUuid', 'MaxVariantID', 'SavedCount'],
            'Node': ['_PW_ID', 'NodeUuid', 'NodeName', 'NodeVariantID', 'NodeNextUuid', 'NodeFirstChildUuid'],
            'Variant': ['_PW_ID', 'VariantID', 'Opacity', 'BrushSize', 'BrushHardness', 'BrushUsePatternImage'],
            'MaterialFile': ['_PW_ID', 'FileData']
        };
    },
    
    getRequiredIndexes() {
        return [];  // CSP doesn't use explicit indexes
    }
};

// ============================================================================
// DEBUG UTILITIES - PRODUCTION ENHANCED
// ============================================================================
const DebugUtils = {
    async runAnalysis() {
        const mode = UI.elements.debugMode.value;
        const results = UI.elements.debugResults;
        
        results.style.display = 'block';
        results.innerHTML = '<strong>üîç Running CSP Analysis...</strong><br><br>';
        
        try {
            switch(mode) {
                case 'csp':
                    await this.analyzeCSPCompatibility(results);
                    break;
                case 'schema':
                    await this.validateCSPSchema(results);
                    break;
                case 'structure':
                    await this.analyzeDatabaseStructure(results);
                    break;
                case 'binary':
                    await this.analyzeBinaryHeaders(results);
                    break;
                case 'performance':
                    await this.analyzePerformance(results);
                    break;
            }
        } catch (error) {
            results.innerHTML += `<br><strong style="color: #dc3545;">‚ùå Analysis Error: ${error.message}</strong>`;
        }
    },
    
    async analyzeCSPCompatibility(results) {
        results.innerHTML += '<strong>üîç CSP 1.12.3+ Compatibility Analysis:</strong><br><br>';
        
        const validationReport = [];
        const schemaComparison = [];
        
        if (!SQL_READY || !SUT_TEMPLATE) {
            validationReport.push({ status: 'fail', message: '‚ùå No template loaded for analysis' });
            UI.showValidationReport(validationReport);
            results.innerHTML += '‚ùå Analysis failed - no template available<br>';
            return;
        }
        
        // Check CSP-specific tables
        const requiredTables = CSPSchema.getRequiredTables();
        let compatible = true;
        
        for (const tableName of requiredTables) {
            try {
                const tableCheck = SUT_TEMPLATE.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?");
                tableCheck.bind([tableName]);
                const tableExists = tableCheck.step();
                tableCheck.free();
                
                if (tableExists) {
                    // Check columns
                    const requiredColumns = CSPSchema.getRequiredColumns()[tableName];
                    const schema = SUT_TEMPLATE.prepare(`PRAGMA table_info(${tableName})`);
                    const existingColumns = [];
                    
                    while (schema.step()) {
                        const col = schema.get();
                        existingColumns.push(col[1]);
                    }
                    schema.free();
                    
                    const missingColumns = requiredColumns.filter(col => !existingColumns.includes(col));
                    
                    if (missingColumns.length === 0) {
                        results.innerHTML += `‚úÖ Table ${tableName}: Valid<br>`;
                        validationReport.push({ status: 'pass', message: `‚úÖ Table ${tableName}: All required columns present` });
                        schemaComparison.push({
                            table: tableName,
                            required: `${requiredColumns.length} columns`,
                            found: `${existingColumns.length} columns`,
                            status: 'ok'
                        });
                    } else {
                        results.innerHTML += `‚ùå Table ${tableName}: Missing columns ${missingColumns.join(', ')}<br>`;
                        validationReport.push({ status: 'fail', message: `‚ùå Table ${tableName}: Missing ${missingColumns.length} columns` });
                        schemaComparison.push({
                            table: tableName,
                            required: `${requiredColumns.length} columns`,
                            found: `${existingColumns.length} columns`,
                            status: 'error'
                        });
                        compatible = false;
                    }
                } else {
                    results.innerHTML += `‚ùå Table ${tableName}: Missing<br>`;
                    validationReport.push({ status: 'fail', message: `‚ùå Table ${tableName}: Not found` });
                    schemaComparison.push({
                        table: tableName,
                        required: 'Required',
                        found: 'Missing',
                        status: 'error'
                    });
                    compatible = false;
                }
            } catch (error) {
                results.innerHTML += `‚ùå Table ${tableName}: Error - ${error.message}<br>`;
                validationReport.push({ status: 'fail', message: `‚ùå Table ${tableName}: Error - ${error.message}` });
                compatible = false;
            }
        }
        
        // Check indexes
        const requiredIndexes = CSPSchema.getRequiredIndexes();
        results.innerHTML += '<br><strong>Checking Indexes:</strong><br>';
        
        for (const indexName of requiredIndexes) {
            try {
                const indexCheck = SUT_TEMPLATE.prepare("SELECT name FROM sqlite_master WHERE type='index' AND name=?");
                indexCheck.bind([indexName]);
                const indexExists = indexCheck.step();
                indexCheck.free();
                
                if (indexExists) {
                    results.innerHTML += `‚úÖ Index ${indexName}: Found<br>`;
                } else {
                    results.innerHTML += `‚ùå Index ${indexName}: Missing<br>`;
                    compatible = false;
                }
            } catch (error) {
                results.innerHTML += `‚ùå Index ${indexName}: Error<br>`;
                compatible = false;
            }
        }
        
        // Check SQLite settings
        results.innerHTML += '<br><strong>Checking SQLite Settings:</strong><br>';
        
        const pageSize = SUT_TEMPLATE.prepare("PRAGMA page_size");
        pageSize.step();
        const pageSizeValue = pageSize.get()[0];
        pageSize.free();
        
        if (pageSizeValue === 4096) {
            results.innerHTML += '‚úÖ Page size: 4096 (CSP compatible)<br>';
        } else {
            results.innerHTML += `‚ùå Page size: ${pageSizeValue} (expected 4096)<br>`;
            compatible = false;
        }
        
        const userVersion = SUT_TEMPLATE.prepare("PRAGMA user_version");
        userVersion.step();
        const versionValue = userVersion.get()[0];
        userVersion.free();
        
        if (versionValue === CSP_VERSION) {
            results.innerHTML += '‚úÖ User version: 100 (CSP compatible)<br>';
        } else {
            results.innerHTML += `‚ùå User version: ${versionValue} (expected 100)<br>`;
            compatible = false;
        }
        
        // Check data integrity
        const integrity = SUT_TEMPLATE.prepare("PRAGMA integrity_check");
        integrity.step();
        const integrityResult = integrity.get();
        integrity.free();
        
        if (integrityResult[0] === 'ok') {
            results.innerHTML += '‚úÖ Database integrity: OK<br>';
        } else {
            results.innerHTML += `‚ùå Database integrity: ${integrityResult[0]}<br>`;
            compatible = false;
        }
        
        UI.showValidationReport(validationReport);
        UI.showSchemaComparison(schemaComparison);
        
        if (compatible) {
            results.innerHTML += '<br><strong style="color: #28a745;">üéâ CSP Compatibility: 100% PASSED</strong>';
            results.innerHTML += '<br>Generated .sut files should be fully compatible with Clip Studio Paint 1.12.3+';
        } else {
            results.innerHTML += '<br><strong style="color: #dc3545;">‚ùå CSP Compatibility: FAILED</strong>';
            results.innerHTML += '<br>Fix the issues above for CSP compatibility.';
        }
    },
    
    async validateCSPSchema(results) {
        results.innerHTML += '<strong>üìã CSP Schema Validation:</strong><br><br>';
        
        if (!SQL_READY || !SUT_TEMPLATE) {
            results.innerHTML += '‚ùå No template loaded for validation<br>';
            return;
        }
        
        const validator = CSPSchemaValidator;
        const schemaReport = await validator.fullValidation(SUT_TEMPLATE);
        
        schemaReport.forEach(item => {
            const icon = item.status === 'pass' ? '‚úÖ' : item.status === 'fail' ? '‚ùå' : '‚ö†Ô∏è';
            results.innerHTML += `${icon} ${item.category}: ${item.message}<br>`;
        });
        
        const allPassed = schemaReport.every(item => item.status !== 'fail');
        
        if (allPassed) {
            results.innerHTML += '<br><strong style="color: #28a745;">üéâ Schema Validation: PASSED</strong>';
        } else {
            results.innerHTML += '<br><strong style="color: #dc3545;">‚ùå Schema Validation: FAILED</strong>';
        }
    },
    
    async analyzeDatabaseStructure(results) {
        if (!SQL_READY || !SUT_TEMPLATE) {
            throw new Error('SQL.js or template not available for analysis');
        }
        
        results.innerHTML += '<strong>üìä Database Structure Analysis:</strong><br><br>';
        
        try {
            // Get table list
            const tables = SUT_TEMPLATE.prepare("SELECT name FROM sqlite_master WHERE type='table'");
            results.innerHTML += '<strong>Tables Found:</strong><br>';
            while (tables.step()) {
                const tableName = tables.get()[0];
                results.innerHTML += `  - ${tableName}<br>`;
                
                // Get table schema
                const schema = SUT_TEMPLATE.prepare(`PRAGMA table_info(${tableName})`);
                results.innerHTML += `    Columns:<br>`;
                while (schema.step()) {
                    const col = schema.get();
                    results.innerHTML += `      ${col[1]} (${col[2]}) ${col[5] ? 'PK' : ''}<br>`;
                }
                schema.free();
            }
            tables.free();
            
            // Check indexes
            const indexes = SUT_TEMPLATE.prepare("SELECT name FROM sqlite_master WHERE type='index'");
            results.innerHTML += '<br><strong>Indexes:</strong><br>';
            while (indexes.step()) {
                results.innerHTML += `  - ${indexes.get()[0]}<br>`;
            }
            indexes.free();
            
        } catch (error) {
            results.innerHTML += `<br><strong style="color: #dc3545;">‚ùå Structure Analysis Error: ${error.message}</strong>`;
        }
    },
    
    async analyzeBinaryHeaders(results) {
        if (!SQL_READY || !SUT_TEMPLATE) {
            throw new Error('SQL.js or template not available for binary analysis');
        }
        
        results.innerHTML += '<strong>üîç Binary Header Analysis:</strong><br><br>';
        
        try {
            const dbData = SUT_TEMPLATE.export();
            const header = new Uint8Array(dbData.slice(0, 100));
            
            results.innerHTML += '<strong>SQLite Header (first 100 bytes):</strong><br>';
            let hexString = '';
            let asciiString = '';
            
            for (let i = 0; i < Math.min(header.length, 100); i++) {
                hexString += header[i].toString(16).padStart(2, '0') + ' ';
                asciiString += (header[i] >= 32 && header[i] <= 126) ? String.fromCharCode(header[i]) : '.';
                
                if ((i + 1) % 16 === 0) {
                    results.innerHTML += `${hexString} | ${asciiString}<br>`;
                    hexString = '';
                    asciiString = '';
                }
            }
            
            // Check specific SQLite header bytes
            const sqliteMagic = new TextDecoder().decode(header.slice(0, 16));
            results.innerHTML += `<br><strong>SQLite Magic String:</strong> "${sqliteMagic}"<br>`;
            
            // Check page size
            const pageSize = (header[16] << 8) | header[17];
            results.innerHTML += `<strong>Page Size:</strong> ${pageSize} bytes<br>`;
            
            // Check file format write version
            results.innerHTML += `<strong>Write Version:</strong> ${header[18]}<br>`;
            results.innerHTML += `<strong>Read Version:</strong> ${header[19]}<br>`;
            
        } catch (error) {
            results.innerHTML += `<br><strong style="color: #dc3545;">‚ùå Binary Analysis Error: ${error.message}</strong>`;
        }
    },
    
    async analyzePerformance(results) {
        results.innerHTML += '<strong>‚ö° Performance Analysis:</strong><br><br>';
        
        // Check Web Worker availability
        if (WORKER && WORKER_READY) {
            results.innerHTML += '‚úÖ Web Worker: Available and ready<br>';
        } else {
            results.innerHTML += '‚ö†Ô∏è Web Worker: Not available (large files may be slow)<br>';
        }
        
        // Check Python backend availability
        if (PythonBackend.enabled) {
            results.innerHTML += '‚úÖ Python Backend: Available and ready<br>';
        } else {
            results.innerHTML += '‚ö†Ô∏è Python Backend: Not available<br>';
        }
        
        // Check memory usage
        if (performance.memory) {
            const memory = performance.memory;
            const usedMB = Math.round(memory.usedJSHeapSize / 1024 / 1024);
            const limitMB = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);
            
            results.innerHTML += `üìä Memory Usage: ${usedMB}MB / ${limitMB}MB<br>`;
            
            if (usedMB > limitMB * 0.8) {
                results.innerHTML += '‚ö†Ô∏è Memory usage is high<br>';
            } else {
                results.innerHTML += '‚úÖ Memory usage is acceptable<br>';
            }
        }
        
        // Check file sizes
        const totalSize = AppState.files.reduce((sum, file) => sum + file.size, 0);
        const sizeMB = Math.round(totalSize / 1024 / 1024);
        
        results.innerHTML += `üìÅ Total file size: ${sizeMB}MB<br>`;
        
        if (sizeMB > 100) {
            results.innerHTML += '‚ö†Ô∏è Large file set - Web Worker or Python recommended<br>';
        } else {
            results.innerHTML += '‚úÖ File size is manageable<br>';
        }
        
        // Browser capabilities
        results.innerHTML += '<br><strong>Browser Capabilities:</strong><br>';
        results.innerHTML += `‚úÖ Canvas support: ${!!document.createElement('canvas').getContext}<br>`;
        results.innerHTML += `‚úÖ Blob support: ${!!window.Blob}<br>`;
        results.innerHTML += `‚úÖ Worker support: ${!!window.Worker}<br>`;
        results.innerHTML += `‚úÖ SQL.js ready: ${SQL_READY}<br>`;
        results.innerHTML += `‚úÖ Current mode: ${CURRENT_MODE}<br>`;
    }
};

// ============================================================================
// CSP SCHEMA VALIDATOR - PRODUCTION READY
// ============================================================================
const CSPSchemaValidator = {
    getRequiredSchema() {
        return CSPSchema.getRequiredTables().reduce((acc, tableName) => {
            acc[tableName] = {
                requiredColumns: CSPSchema.getRequiredColumns()[tableName].map(col => ({ name: col, notNull: true }))
            };
            return acc;
        }, {});
    },
    
    async validateTable(db, tableName, tableInfo) {
        try {
            // Check if table exists
            const tableCheck = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name=?");
            tableCheck.bind([tableName]);
            const tableExists = tableCheck.step();
            tableCheck.free();
            
            if (!tableExists) {
                return { valid: false, error: `Table ${tableName} does not exist` };
            }
            
            // Get table schema
            const schema = db.prepare(`PRAGMA table_info(${tableName})`);
            const existingColumns = {};
            
            while (schema.step()) {
                const col = schema.get();
                existingColumns[col[1]] = {
                    type: col[2],
                    notNull: col[3] === 1,
                    defaultValue: col[4],
                    primaryKey: col[5] === 1
                };
            }
            schema.free();
            
            // Validate required columns
            for (const colInfo of tableInfo.requiredColumns) {
                if (!existingColumns[colInfo.name]) {
                    return { valid: false, error: `Missing column ${colInfo.name}` };
                }
            }
            
            return { valid: true };
            
        } catch (error) {
            return { valid: false, error: error.message };
        }
    },
    
    async fullValidation(db) {
        const report = [];
        const schema = this.getRequiredSchema();
        
        // Check each table
        for (const [tableName, tableInfo] of Object.entries(schema)) {
            const validation = await this.validateTable(db, tableName, tableInfo);
            
            if (validation.valid) {
                report.push({
                    category: `Table ${tableName}`,
                    status: 'pass',
                    message: 'All required columns present and correctly configured'
                });
            } else {
                report.push({
                    category: `Table ${tableName}`,
                    status: 'fail',
                    message: validation.error
                });
            }
        }
        
        // Check database settings
        try {
            const integrity = db.prepare("PRAGMA integrity_check");
            integrity.step();
            const result = integrity.get();
            integrity.free();
            
            if (result[0] === 'ok') {
                report.push({
                    category: 'Database Integrity',
                    status: 'pass',
                    message: 'Database integrity check passed'
                });
            } else {
                report.push({
                    category: 'Database Integrity',
                    status: 'fail',
                    message: `Integrity check failed: ${result[0]}`
                });
            }
        } catch (error) {
            report.push({
                category: 'Database Integrity',
                status: 'fail',
                message: `Cannot check integrity: ${error.message}`
            });
        }
        
        return report;
    }
};

// ============================================================================
// CSP UUID GENERATOR - CSP SPECIFIC FORMAT
// ============================================================================
const CSPUUIDGenerator = {
    generateCSPUUID() {
        // CSP uses random 16-byte UUIDs (not timestamp-based)
        const uuid = new Uint8Array(16);
        crypto.getRandomValues(uuid);
        return uuid;
    },
    
    generateUuidBlob() {
        return this.generateCSPUUID();
    },
    
    uuidToString(uuid) {
        const hex = Array.from(uuid).map(b => b.toString(16).padStart(2, '0')).join('');
        return hex;
    }
};

// ============================================================================
// CSP ENCODING UTILITIES - BINARY FORMATS
// ============================================================================
const CSPEncodingUtils = {
    // Encode BrushPatternImageArray with material reference
    encodeBrushPatternArray(brushName, materialUuid) {
        // Format: [header(4)][count(4)][length(4)][unknown(4)][utf16-string][more-data]
        // Based on sample.sut analysis
        
        if (!materialUuid) {
            // No material - return minimal header
            return new Uint8Array([
                0x00, 0x00, 0x00, 0x08,  // Header: 8
                0x00, 0x00, 0x00, 0x01,  // Count: 1
                0x00, 0x00, 0x00, 0x00,  // Length: 0
                0x00, 0x00, 0x00, 0x00   // Unknown: 0
            ]);
        }
        
        // Create material reference string (UTF-16LE)
        // Format: ".:12:45:uuid:data:material_0.layer"
        const refString = `.:12:45:${materialUuid}:data:material_0.layer`;
        const encoder = new TextEncoder();
        
        // Encode as UTF-16LE
        const utf16Data = new Uint16Array(refString.length + 1); // +1 for null terminator
        for (let i = 0; i < refString.length; i++) {
            utf16Data[i] = refString.charCodeAt(i);
        }
        utf16Data[refString.length] = 0; // Null terminator
        
        const utf16Bytes = new Uint8Array(utf16Data.buffer);
        
        // Additional data after string
        const additionalData = new Uint8Array([
            0x00, 0x00, 0x02, 0x00,  // Some flag/type
            0x00, 0x00, 0x00, 0x14   // Another value
        ]);
        
        // Encode brush name as UTF-16LE
        const nameUtf16 = new Uint16Array(brushName.length + 1);
        for (let i = 0; i < brushName.length; i++) {
            nameUtf16[i] = brushName.charCodeAt(i);
        }
        nameUtf16[brushName.length] = 0;
        const nameBytes = new Uint8Array(nameUtf16.buffer);
        
        // Calculate total length
        const dataLength = utf16Bytes.length + additionalData.length + nameBytes.length + 8;
        
        // Build header
        const header = new Uint8Array(16);
        const view = new DataView(header.buffer);
        view.setUint32(0, 8, false);  // Header: 8 (big-endian)
        view.setUint32(4, 1, false);  // Count: 1 (big-endian)
        view.setUint32(8, dataLength, false);  // Data length (big-endian)
        view.setUint32(12, 132, false);  // Unknown: 132 (big-endian)
        
        // Combine all parts
        const result = new Uint8Array(16 + dataLength);
        result.set(header, 0);
        result.set(utf16Bytes, 16);
        result.set(additionalData, 16 + utf16Bytes.length);
        result.set(nameBytes, 16 + utf16Bytes.length + additionalData.length);
        
        return result;
    },
    
    // Encode effector BLOB for pressure sensitivity
    encodeEffectorBlob(enabled, curvePoints) {
        if (!enabled || !curvePoints) {
            return null;
        }
        
        // CSP effector format (simplified)
        // This is a basic implementation - actual format may be more complex
        const header = new Uint8Array([
            0x01, 0x00, 0x00, 0x00,  // Enabled flag
            0x00, 0x00, 0x00, 0x00   // Type/mode
        ]);
        
        // Encode curve points as float pairs
        const pointCount = Math.min(curvePoints.length, 10); // Limit to 10 points
        const curveData = new Float32Array(pointCount * 2);
        
        for (let i = 0; i < pointCount; i++) {
            const point = curvePoints[i];
            curveData[i * 2] = point[0];      // X (0.0 - 1.0)
            curveData[i * 2 + 1] = point[1];  // Y (0.0 - 1.0)
        }
        
        // Combine header and curve data
        const result = new Uint8Array(header.length + 4 + curveData.byteLength);
        result.set(header, 0);
        
        // Point count
        const countView = new DataView(result.buffer, header.length, 4);
        countView.setUint32(0, pointCount, true);  // Little-endian
        
        // Curve data
        result.set(new Uint8Array(curveData.buffer), header.length + 4);
        
        return result;
    },
    
    // Generate a simple UUID string for material references
    generateMaterialUuid() {
        const chars = '0123456789abcdef';
        let uuid = '';
        for (let i = 0; i < 32; i++) {
            uuid += chars[Math.floor(Math.random() * 16)];
            if (i === 7 || i === 11 || i === 15 || i === 19) {
                uuid += '-';
            }
        }
        return uuid;
    }
};

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
function concatenateArrays(arrays) {
    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}

// ============================================================================
// PRESSURE CURVE UTILITIES
// ============================================================================
const PressureCurveUtils = {
    curveData: {},
    
    createPressureCurve(points) {
        const validatedPoints = [];
        for (const [x, y] of points) {
            const xClamped = Math.max(0.0, Math.min(1.0, x));
            const yClamped = Math.max(0.0, Math.min(1.0, y));
            validatedPoints.push([xClamped, yClamped]);
        }
        
        validatedPoints.sort((a, b) => a[0] - b[0]);
        
        if (validatedPoints.length < 2) {
            validatedPoints.push([0.0, 0.0], [1.0, 1.0]);
        }
        
        return CSPEncodingUtils.encodeCSPPressureCurve(validatedPoints);
    },

    initCurveEditors() {
        const curves = {
            size: { canvas: document.getElementById('sizeCurveCanvas'), points: [[0,0], [0.3,0.2], [0.7,0.8], [1,1]] },
            opacity: { canvas: document.getElementById('opacityCurveCanvas'), points: [[0,0], [0.5,0.3], [1,1]] },
            density: { canvas: document.getElementById('densityCurveCanvas'), points: [[0,0], [1,1]] }
        };

        Object.keys(curves).forEach(type => {
            const curve = curves[type];
            this.setupCurveEditor(curve.canvas, curve.points, type);
            
            document.getElementById(`reset${type.charAt(0).toUpperCase() + type.slice(1)}Curve`)
                .addEventListener('click', () => {
                    curve.points = type === 'size' ? [[0,0], [0.3,0.2], [0.7,0.8], [1,1]] :
                                   type === 'opacity' ? [[0,0], [0.5,0.3], [1,1]] :
                                   [[0,0], [1,1]];
                    this.drawCurve(curve.canvas, curve.points);
                });
        });
        
        this.curveData = curves;
    },

    setupCurveEditor(canvas, points, type) {
        const ctx = canvas.getContext('2d');
        let isDragging = false;
        let dragIndex = -1;
        
        const draw = () => this.drawCurve(canvas, points);
        
        const getEventPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) / rect.width,
                y: 1 - (clientY - rect.top) / rect.height
            };
        };

        const getPointIndex = (pos) => {
            for (let i = 0; i < points.length; i++) {
                const dx = pos.x - points[i][0];
                const dy = pos.y - points[i][1];
                if (Math.sqrt(dx*dx + dy*dy) < 0.05) {
                    return i;
                }
            }
            return -1;
        };

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            const pos = getEventPos(e);
            dragIndex = getPointIndex(pos);
            if (dragIndex !== -1) {
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
            e.preventDefault();
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getEventPos(e);
            if (isDragging && dragIndex !== -1) {
                if (dragIndex === 0) {
                    points[dragIndex] = [0, Math.max(0, Math.min(1, pos.y))];
                } else if (dragIndex === points.length - 1) {
                    points[dragIndex] = [1, Math.max(0, Math.min(1, pos.y))];
                } else {
                    points[dragIndex] = [
                        Math.max(points[dragIndex-1][0] + 0.01, Math.min(points[dragIndex+1][0] - 0.01, pos.x)),
                        Math.max(0, Math.min(1, pos.y))
                    ];
                }
                draw();
            } else {
                canvas.style.cursor = getPointIndex(pos) !== -1 ? 'grab' : 'crosshair';
            }
            e.preventDefault();
        });

        canvas.addEventListener('mouseup', (e) => {
            isDragging = false;
            dragIndex = -1;
            canvas.style.cursor = 'crosshair';
            e.preventDefault();
        });

        canvas.addEventListener('mouseleave', (e) => {
            isDragging = false;
            dragIndex = -1;
            canvas.style.cursor = 'crosshair';
            e.preventDefault();
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            const pos = getEventPos(e);
            dragIndex = getPointIndex(pos);
            if (dragIndex !== -1) {
                isDragging = true;
            }
            e.preventDefault();
        });

        canvas.addEventListener('touchmove', (e) => {
            if (isDragging && dragIndex !== -1) {
                const pos = getEventPos(e);
                if (dragIndex === 0) {
                    points[dragIndex] = [0, Math.max(0, Math.min(1, pos.y))];
                } else if (dragIndex === points.length - 1) {
                    points[dragIndex] = [1, Math.max(0, Math.min(1, pos.y))];
                } else {
                    points[dragIndex] = [
                        Math.max(points[dragIndex-1][0] + 0.01, Math.min(points[dragIndex+1][0] - 0.01, pos.x)),
                        Math.max(0, Math.min(1, pos.y))
                    ];
                }
                draw();
            }
            e.preventDefault();
        });

        canvas.addEventListener('touchend', (e) => {
            isDragging = false;
            dragIndex = -1;
            e.preventDefault();
        });

        draw();
    },

    drawCurve(canvas, points) {
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        // Draw grid
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
            const x = (width / 10) * i;
            const y = (height / 10) * i;
            
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        
        // Draw curve
        ctx.strokeStyle = '#667eea';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < points.length; i++) {
            const x = points[i][0] * width;
            const y = (1 - points[i][1]) * height;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
        
        // Draw control points
        ctx.fillStyle = '#667eea';
        for (const point of points) {
            const x = point[0] * width;
            const y = (1 - point[1]) * height;
            
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
        }
    }
};

// ============================================================================
// FILE MANAGER - ENHANCED
// ============================================================================
const FileManager = {
    async handleFiles(files) {
        try {
            UI.showLoading(true);
            Logger.info(`Processing ${files.length} file(s)...`);
            
            const validFiles = [];
            const invalidFiles = [];
            
            for (const file of files) {
                if (file.size > AppState.maxFileSize) {
                    Logger.warning(`File too large: ${file.name} (${Math.round(file.size/1024/1024)}MB)`);
                    invalidFiles.push({ name: file.name, error: 'File too large' });
                    continue;
                }
                
                const ext = file.name.toLowerCase().split('.').pop();
                if (['png', 'jpg', 'jpeg', 'abr', 'zip', 'brushset'].includes(ext)) {
                    validFiles.push(file);
                } else {
                    Logger.warning(`Unsupported file type: ${file.name}`);
                    invalidFiles.push({ name: file.name, error: 'Unsupported file type' });
                }
            }
            
            if (validFiles.length === 0) {
                Logger.error('No valid files to process');
                UI.showStatus('No valid files found', 'error');
                return;
            }
            
            AppState.files = validFiles;
            AppState.stats.filesLoaded = validFiles.length;
            
            // Process files based on type
            const zipFiles = validFiles.filter(f => f.name.toLowerCase().endsWith('.zip') || f.name.toLowerCase().endsWith('.brushset'));
            const imageFiles = validFiles.filter(f => ['png', 'jpg', 'jpeg'].includes(f.name.toLowerCase().split('.').pop()));
            const abrFiles = validFiles.filter(f => f.name.toLowerCase().endsWith('.abr'));
            
            const allBrushes = [];
            
            // Process ZIP files
            for (const zipFile of zipFiles) {
                const brushes = await this.processZipFile(zipFile);
                allBrushes.push(...brushes);
            }
            
            // Process image files
            for (const imageFile of imageFiles) {
                const brush = await this.processImageFile(imageFile);
                if (brush) {
                    allBrushes.push(brush);
                }
            }
            
            // Process ABR files
            for (const abrFile of abrFiles) {
                const brushes = await this.processAbrFile(abrFile);
                allBrushes.push(...brushes);
            }
            
            AppState.brushes = allBrushes;
            AppState.stats.brushesParsed = allBrushes.length;
            AppState.filesLoaded = true;
            
            UI.updateStats();
            UI.updatePreview(allBrushes);
            
            const format = UI.elements.outputFormat.value;
            if (format === 'png' || format === 'debug') {
                UI.enableConvertButton();
            } else if (format === 'sut' && !AppState.templateLoaded) {
                UI.elements.templateSelector.style.display = 'block';
                UI.showInfo('SUT format requires a template. Choose default or load a custom template below.');
            }
            
            Logger.success(`Successfully loaded ${allBrushes.length} brush(es) from ${validFiles.length} file(s)`);
            UI.showStatus(`Loaded ${allBrushes.length} brushes`, 'success');
            
        } catch (error) {
            Logger.error(`File processing error: ${error.message}`);
            UI.showStatus(`Error processing files: ${error.message}`, 'error');
        } finally {
            UI.showLoading(false);
        }
    },
    
    async processProcreateSet(zipData, fileName) {
        const brushes = [];
        
        try {
            Logger.info('Parsing Procreate brushset...');
            
            // Procreate brushsets contain:
            // - Brushes.archive (binary plist with brush metadata)
            // - PNG files for brush shapes (named with UUIDs)
            // - Grain images for textures
            
            // Collect all PNG files (brush shapes)
            const brushImages = [];
            zipData.forEach((relativePath, file) => {
                if (!file.dir && relativePath.toLowerCase().endsWith('.png')) {
                    // Skip grain/texture files (usually in Grain folder)
                    if (!relativePath.toLowerCase().includes('grain')) {
                        brushImages.push({ file, path: relativePath });
                    }
                }
            });
            
            Logger.info(`Found ${brushImages.length} brush images in Procreate set`);
            
            // Try to parse Brushes.archive if it exists
            const archiveFile = zipData.file('Brushes.archive');
            let brushMetadata = [];
            
            if (archiveFile) {
                try {
                    const archiveData = await archiveFile.async('uint8array');
                    brushMetadata = this.parseProcreateArchive(archiveData);
                    Logger.info(`Parsed ${brushMetadata.length} brush definitions from archive`);
                } catch (error) {
                    Logger.warning(`Could not parse Brushes.archive: ${error.message}`);
                }
            }
            
            // Process each brush image
            for (let i = 0; i < brushImages.length; i++) {
                const { file, path } = brushImages[i];
                
                try {
                    const blob = await file.async('blob');
                    const fileName = path.split('/').pop();
                    const brushName = fileName.replace('.png', '');
                    
                    // Try to find metadata for this brush
                    const metadata = brushMetadata.find(m => 
                        m.shapeImage && m.shapeImage.includes(brushName)
                    ) || {};
                    
                    const imageFile = new File([blob], fileName, { type: 'image/png' });
                    const brush = await this.processImageFile(imageFile);
                    
                    if (brush) {
                        // Use Procreate brush name if available
                        if (metadata.name) {
                            brush.name = UI.sanitizeName(metadata.name);
                        } else {
                            brush.name = UI.sanitizeName(`Procreate_${i + 1}`);
                        }
                        
                        // Apply Procreate settings if available
                        if (metadata.size) {
                            brush.settings.size = Math.round(metadata.size * 100);
                        }
                        if (metadata.opacity) {
                            brush.settings.opacity = Math.round(metadata.opacity * 100);
                        }
                        if (metadata.spacing) {
                            brush.settings.spacing = Math.round(metadata.spacing * 100);
                        }
                        
                        brush.metadata = {
                            ...brush.metadata,
                            source: 'Procreate',
                            extractedFrom: fileName,
                            procreateMetadata: metadata
                        };
                        
                        brushes.push(brush);
                    }
                } catch (error) {
                    Logger.warning(`Failed to process Procreate brush ${path}: ${error.message}`);
                }
            }
            
            Logger.success(`Extracted ${brushes.length} brushes from Procreate set`);
            
        } catch (error) {
            Logger.error(`Procreate brushset processing error: ${error.message}`);
        }
        
        return brushes;
    },
    
    parseProcreateArchive(data) {
        // Procreate's Brushes.archive is a binary plist format
        // This is a simplified parser that extracts basic information
        const brushes = [];
        
        try {
            // Convert to string to search for brush names and properties
            const text = new TextDecoder('utf-8', { fatal: false }).decode(data);
            
            // Look for brush name patterns
            // Procreate stores brush names as strings in the plist
            const nameMatches = text.match(/brushName[^\x00]{1,100}?([A-Za-z0-9 _-]{3,50})/g);
            
            if (nameMatches) {
                nameMatches.forEach(match => {
                    const name = match.replace(/brushName[^\x00]*?([A-Za-z0-9 _-]+).*/, '$1').trim();
                    if (name && name.length > 2) {
                        brushes.push({
                            name: name,
                            size: 0.5,  // Default values
                            opacity: 1.0,
                            spacing: 0.1
                        });
                    }
                });
            }
            
            // If no names found, return empty array
            // The caller will use default names
            
        } catch (error) {
            Logger.warning(`Archive parsing error: ${error.message}`);
        }
        
        return brushes;
    },
    
    async processZipFile(zipFile, depth = 0) {
        const brushes = [];
        const MAX_DEPTH = 5; // Prevent infinite recursion
        
        try {
            // Check recursion depth
            if (depth >= MAX_DEPTH) {
                Logger.warning(`Maximum ZIP nesting depth reached for ${zipFile.name}`);
                return brushes;
            }
            
            const zip = new JSZip();
            const zipData = await zip.loadAsync(zipFile);
            
            Logger.info(`Extracting ZIP: ${zipFile.name} (depth: ${depth})`);
            
            // Check if this is a Procreate brushset
            const isProcreate = zipFile.name.toLowerCase().endsWith('.brushset') || 
                               zipData.file('Brushes.archive') !== null;
            
            if (isProcreate) {
                Logger.info(`Detected Procreate brushset: ${zipFile.name}`);
                const procreateBrushes = await this.processProcreateSet(zipData, zipFile.name);
                return procreateBrushes;
            }
            
            // Collect files by type
            const imageFiles = [];
            const abrFiles = [];
            const nestedZipFiles = [];
            
            zipData.forEach((relativePath, file) => {
                if (file.dir) {
                    return; // Skip directories
                }
                
                const ext = relativePath.toLowerCase().split('.').pop();
                
                if (['png', 'jpg', 'jpeg'].includes(ext)) {
                    imageFiles.push({ file, path: relativePath });
                } else if (ext === 'abr') {
                    abrFiles.push({ file, path: relativePath });
                } else if (['zip', 'brushset'].includes(ext)) {
                    nestedZipFiles.push({ file, path: relativePath });
                }
            });
            
            Logger.info(`Found in ${zipFile.name}: ${imageFiles.length} images, ${abrFiles.length} ABR files, ${nestedZipFiles.length} nested archives`);
            
            // Process image files
            for (const { file, path } of imageFiles) {
                try {
                    const blob = await file.async('blob');
                    const fileName = path.split('/').pop(); // Get filename without path
                    const imageFile = new File([blob], fileName, { type: 'image/png' });
                    const brush = await this.processImageFile(imageFile);
                    
                    if (brush) {
                        brush.metadata = {
                            ...brush.metadata,
                            extractedFrom: zipFile.name,
                            originalPath: path
                        };
                        brushes.push(brush);
                    }
                } catch (error) {
                    Logger.warning(`Failed to process image ${path}: ${error.message}`);
                }
            }
            
            // Process ABR files
            for (const { file, path } of abrFiles) {
                try {
                    const blob = await file.async('blob');
                    const fileName = path.split('/').pop();
                    const abrFile = new File([blob], fileName, { type: 'application/octet-stream' });
                    const abrBrushes = await this.processAbrFile(abrFile);
                    
                    // Add metadata to each brush
                    abrBrushes.forEach(brush => {
                        brush.metadata = {
                            ...brush.metadata,
                            extractedFrom: zipFile.name,
                            originalPath: path
                        };
                    });
                    
                    brushes.push(...abrBrushes);
                } catch (error) {
                    Logger.warning(`Failed to process ABR ${path}: ${error.message}`);
                }
            }
            
            // Process nested ZIP files recursively
            for (const { file, path } of nestedZipFiles) {
                try {
                    const blob = await file.async('blob');
                    const fileName = path.split('/').pop();
                    const nestedZipFile = new File([blob], fileName, { type: 'application/zip' });
                    
                    Logger.info(`Processing nested archive: ${path}`);
                    const nestedBrushes = await this.processZipFile(nestedZipFile, depth + 1);
                    
                    // Add metadata to nested brushes
                    nestedBrushes.forEach(brush => {
                        brush.metadata = {
                            ...brush.metadata,
                            nestedIn: zipFile.name
                        };
                    });
                    
                    brushes.push(...nestedBrushes);
                } catch (error) {
                    Logger.warning(`Failed to process nested ZIP ${path}: ${error.message}`);
                }
            }
            
            Logger.success(`Extracted ${brushes.length} total brushes from ${zipFile.name}`);
            
        } catch (error) {
            Logger.error(`ZIP processing error for ${zipFile.name}: ${error.message}`);
        }
        
        return brushes;
    },
    
    async processImageFile(imageFile) {
        try {
            const url = URL.createObjectURL(imageFile);
            MemoryManager.addBlobUrl(url);
            
            const brush = {
                name: UI.sanitizeName(imageFile.name.replace(/\.[^/.]+$/, '')),
                type: 'image',
                tipPNGs: [url],
                width: 0,
                height: 0,
                settings: this.getDefaultSettings()
            };
            
            // Get image dimensions
            const img = new Image();
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = url;
            });
            
            brush.width = img.width;
            brush.height = img.height;
            
            Logger.info(`Processed image: ${brush.name} (${brush.width}x${brush.height})`);
            
            return brush;
            
        } catch (error) {
            Logger.error(`Image processing error: ${error.message}`);
            return null;
        }
    },
    
    async processAbrFile(abrFile) {
        const brushes = [];
        
        try {
            const arrayBuffer = await abrFile.arrayBuffer();
            const abrData = new Uint8Array(arrayBuffer);
            
            Logger.info(`Parsing ABR: ${abrFile.name}`);
            
            // Use Web Worker if available
            if (WORKER && WORKER_READY && UI.elements.useWebWorker.checked) {
                const result = await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('ABR parsing timeout'));
                    }, 30000); // 30 second timeout
                    
                    WORKER.onmessage = (e) => {
                        clearTimeout(timeout);
                        if (e.data.type === 'complete') {
                            resolve(e.data.brushes || []);
                        } else if (e.data.error) {
                            reject(new Error(e.data.error));
                        }
                    };
                    
                    WORKER.postMessage({ type: 'parseABR', data: abrData });
                });
                
                // Convert parsed brush data to brush objects
                for (const brushData of result) {
                    brushes.push({
                        name: UI.sanitizeName(brushData.name),
                        type: 'abr',
                        tipPNGs: brushData.imageData ? [brushData.imageData] : [],
                        width: 512,
                        height: 512,
                        settings: {
                            ...this.getDefaultSettings(),
                            size: brushData.size || 50,
                            hardness: brushData.hardness || 50,
                            spacing: brushData.spacing || 25,
                            angle: brushData.angle || 0
                        },
                        metadata: {
                            originalFile: abrFile.name,
                            dateAdded: Date.now(),
                            fileSize: abrFile.size,
                            roundness: brushData.roundness || 100
                        }
                    });
                }
                
                Logger.success(`Parsed ${brushes.length} brushes from ${abrFile.name}`);
            } else {
                // Fallback: parse in main thread (slower but works)
                Logger.warning('Web Worker not available, parsing ABR in main thread');
                
                // Simple inline parsing for fallback
                const header = this.parseABRHeaderInline(abrData);
                
                if (header && header.count > 0) {
                    const count = Math.min(header.count, 50); // Limit to 50 brushes
                    
                    for (let i = 0; i < count; i++) {
                        brushes.push({
                            name: UI.sanitizeName(`${abrFile.name.replace('.abr', '')}_${i + 1}`),
                            type: 'abr',
                            tipPNGs: [],
                            width: 512,
                            height: 512,
                            settings: this.getDefaultSettings(),
                            metadata: {
                                originalFile: abrFile.name,
                                dateAdded: Date.now(),
                                fileSize: abrFile.size
                            }
                        });
                    }
                    
                    Logger.info(`Created ${brushes.length} brush placeholders from ${abrFile.name}`);
                } else {
                    Logger.warning(`Could not parse ABR header: ${abrFile.name}`);
                }
            }
            
        } catch (error) {
            Logger.error(`ABR processing error for ${abrFile.name}: ${error.message}`);
        }
        
        return brushes;
    },
    
    parseABRHeaderInline(data) {
        // Simple header parsing for fallback
        if (data.length < 4) {
            return null;
        }
        
        const version = (data[0] << 8) | data[1];
        const count = (data[2] << 8) | data[3];
        
        if (version < 1 || version > 10 || count < 1 || count > 1000) {
            return null;
        }
        
        return { version, count };
    },
    
    getDefaultSettings() {
        return {
            size: parseInt(document.getElementById('brushSize').value),
            opacity: parseInt(document.getElementById('opacity').value),
            spacing: parseInt(document.getElementById('spacing').value),
            hardness: parseInt(document.getElementById('hardness').value),
            angle: parseInt(document.getElementById('angle').value),
            density: parseInt(document.getElementById('density').value),
            smoothing: parseInt(document.getElementById('smoothing').value),
            stabilization: parseInt(document.getElementById('stabilization').value),
            textureMode: document.getElementById('textureMode').checked,
            sizePressure: document.getElementById('sizePressure').checked,
            opacityPressure: document.getElementById('opacityPressure').checked,
            densityPressure: document.getElementById('densityPressure').checked,
            antiAliasing: document.getElementById('antiAliasing').checked
        };
    }
};

// ============================================================================
// TEMPLATE MANAGER - CSP COMPATIBLE
// ============================================================================
const TemplateManager = {
    async loadDefaultTemplate() {
        try {
            if (!SQL_READY) {
                throw new Error('SQL.js not ready');
            }
            
            Logger.info('Creating CSP-compatible default template...');
            
            SUT_TEMPLATE = new SQL.Database();
            
            // Execute correct CSP schema
            SUT_TEMPLATE.run(CSPSchema.FULL_SCHEMA);
            
            // Insert Manager record
            const rootUuid = CSPUUIDGenerator.generateUuidBlob();
            
            SUT_TEMPLATE.run(`
                INSERT INTO Manager (ToolType, Version, RootUuid, MaxVariantID, SavedCount)
                VALUES (0, 126, ?, 1000, 0)
            `, [rootUuid]);
            
            // Insert root Node
            SUT_TEMPLATE.run(`
                INSERT INTO Node (NodeUuid, NodeName, NodeLock, NodeHidden, NodeFirstChildUuid)
                VALUES (?, 'Root Tool', 0, 0, NULL)
            `, [rootUuid]);
            
            AppState.templateLoaded = true;
            Logger.success('Default CSP template created successfully');
            UI.showStatus('Default CSP template loaded', 'success');
            UI.elements.templateSelector.style.display = 'none';
            UI.hideInfo();
            
            if (AppState.filesLoaded) {
                UI.enableConvertButton();
            }
            
        } catch (error) {
            Logger.error(`Template creation error: ${error.message}`);
            UI.showStatus(`Template error: ${error.message}`, 'error');
        }
    },
    
    async loadTemplate(file) {
        try {
            if (!SQL_READY) {
                throw new Error('SQL.js not ready');
            }
            
            Logger.info(`Loading template: ${file.name}`);
            
            const arrayBuffer = await file.arrayBuffer();
            const u8Array = new Uint8Array(arrayBuffer);
            
            // Validate SQLite header
            const header = new TextDecoder().decode(u8Array.slice(0, 16));
            if (!header.startsWith('SQLite format 3')) {
                throw new Error('Invalid SUT file - not a valid SQLite database');
            }
            
            SUT_TEMPLATE = new SQL.Database(u8Array);
            
            // Validate CSP schema
            const validator = CSPSchemaValidator;
            const validation = await validator.fullValidation(SUT_TEMPLATE);
            
            const hasErrors = validation.some(item => item.status === 'fail');
            if (hasErrors) {
                Logger.warning('Template has validation issues - may not be fully CSP compatible');
                UI.showValidationReport(validation);
            } else {
                Logger.success('Template passed CSP validation');
            }
            
            AppState.templateLoaded = true;
            UI.showStatus(`Template loaded: ${file.name}`, 'success');
            UI.elements.templateSelector.style.display = 'none';
            UI.hideInfo();
            
            if (AppState.filesLoaded) {
                UI.enableConvertButton();
            }
            
        } catch (error) {
            Logger.error(`Template loading error: ${error.message}`);
            UI.showStatus(`Template error: ${error.message}`, 'error');
        }
    }
};

// ============================================================================
// BRUSH PARSER - CSP COMPATIBLE
// ============================================================================
const BrushParser = {
    cleanup() {
        // Clean up any resources
    }
};

// ============================================================================
// CONVERTER - CSP COMPATIBLE
// ============================================================================
const Converter = {
    async convertAll() {
        if (AppState.converting) {
            Logger.warning('Conversion already in progress');
            return;
        }
        
        const format = UI.elements.outputFormat.value;
        
        try {
            AppState.converting = true;
            AppState.abortController = new AbortController();
            
            UI.disableConvertButton();
            UI.elements.cancelBtn.disabled = false;
            UI.showProgress(0);
            
            Logger.info(`Starting conversion in ${CURRENT_MODE} mode...`);
            
            switch(format) {
                case 'sut':
                    await this.convertToSUT();
                    break;
                case 'png':
                    await this.convertToPNG();
                    break;
                case 'debug':
                    await this.runDebugConversion();
                    break;
            }
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                Logger.error(`Conversion error: ${error.message}`);
                UI.showStatus(`Conversion failed: ${error.message}`, 'error');
            }
        } finally {
            AppState.converting = false;
            AppState.abortController = null;
            UI.enableConvertButton();
            UI.elements.cancelBtn.disabled = true;
            UI.hideProgress();
        }
    },
    
    async convertAllPython() {
        if (AppState.converting) {
            Logger.warning('Conversion already in progress');
            return;
        }
        
        try {
            AppState.converting = true;
            AppState.abortController = new AbortController();
            
            UI.disableConvertButton();
            UI.elements.cancelBtn.disabled = false;
            
            const settings = {
                format: 'sut',
                compression: parseInt(document.getElementById('compressionLevel').value),
                ...FileManager.getDefaultSettings()
            };
            
            await PythonBackend.convertFiles(AppState.files, settings);
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                Logger.error(`Python conversion error: ${error.message}`);
                UI.showStatus(`Python conversion failed: ${error.message}`, 'error');
            }
        } finally {
            AppState.converting = false;
            AppState.abortController = null;
            UI.enableConvertButton();
            UI.elements.cancelBtn.disabled = true;
        }
    },
    
    async convertToSUT() {
        if (!SQL_READY || !SUT_TEMPLATE) {
            throw new Error('SQL.js or template not available');
        }
        
        Logger.info('Creating CSP-compatible .sut file with CORRECT schema...');
        
        const packageName = UI.sanitizeName(document.getElementById('packageName').value);
        
        // Create new database from template
        const db = new SQL.Database(SUT_TEMPLATE.export());
        
        // Get root UUID from Manager
        let rootUuid = null;
        const rootQuery = db.prepare('SELECT RootUuid FROM Manager WHERE _PW_ID = 1');
        if (rootQuery.step()) {
            rootUuid = rootQuery.get()[0];
        }
        rootQuery.free();
        
        if (!rootUuid) {
            throw new Error('Invalid template - missing root UUID');
        }
        
        const convertedBrushes = [];
        const failedBrushes = [];
        let variantIdCounter = 1000;  // Start from 1000
        let prevNodeUuid = null;
        let firstBrushUuid = null;
        
        for (let i = 0; i < AppState.brushes.length; i++) {
            const brush = AppState.brushes[i];
            
            try {
                // Check for abort
                if (AppState.abortController.signal.aborted) {
                    throw new Error('Conversion aborted');
                }
                
                // Generate UUIDs and IDs
                const nodeUuid = CSPUUIDGenerator.generateUuidBlob();
                const variantId = ++variantIdCounter;
                const initVariantId = ++variantIdCounter;  // Separate ID for initial variant
                
                // Track first brush for root node
                if (i === 0) {
                    firstBrushUuid = nodeUuid;
                }
                
                // Generate material UUID for brush tip reference
                const materialUuid = brush.tipPNGs && brush.tipPNGs.length > 0 ? 
                    CSPEncodingUtils.generateMaterialUuid() : null;
                
                // Get pressure curves if available
                const sizeCurve = brush.settings.sizePressure && PressureCurveUtils.curveData.size ? 
                    PressureCurveUtils.curveData.size.points : null;
                const opacityCurve = brush.settings.opacityPressure && PressureCurveUtils.curveData.opacity ? 
                    PressureCurveUtils.curveData.opacity.points : null;
                
                // Prepare variant data
                const variantData = [
                    brush.settings.opacity || 100,
                    brush.settings.antiAliasing ? 1 : 0,
                    0,  // CompositeMode: 0 = normal
                    brush.settings.size || 50.0,
                    0,  // BrushSizeUnit: 0 = pixels
                    CSPEncodingUtils.encodeEffectorBlob(brush.settings.sizePressure, sizeCurve),
                    brush.settings.opacity || 100,
                    CSPEncodingUtils.encodeEffectorBlob(brush.settings.opacityPressure, opacityCurve),
                    brush.settings.hardness || 50,
                    brush.settings.spacing || 10.0,
                    100,  // BrushThickness: 100%
                    brush.settings.angle || 0.0,
                    materialUuid ? 1 : 0,  // BrushUsePatternImage: 1 if has tip
                    CSPEncodingUtils.encodeBrushPatternArray(brush.name, materialUuid)
                ];
                
                // Insert CURRENT Variant record
                db.run(`
                    INSERT INTO Variant (
                        VariantID, Opacity, AntiAlias, CompositeMode,
                        BrushSize, BrushSizeUnit, BrushSizeEffector,
                        BrushFlow, BrushFlowEffector,
                        BrushHardness, BrushInterval,
                        BrushThickness, BrushRotation,
                        BrushUsePatternImage, BrushPatternImageArray
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [variantId, ...variantData]);
                
                // Insert INITIAL Variant record (same settings)
                db.run(`
                    INSERT INTO Variant (
                        VariantID, Opacity, AntiAlias, CompositeMode,
                        BrushSize, BrushSizeUnit, BrushSizeEffector,
                        BrushFlow, BrushFlowEffector,
                        BrushHardness, BrushInterval,
                        BrushThickness, BrushRotation,
                        BrushUsePatternImage, BrushPatternImageArray
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [initVariantId, ...variantData]);
                
                // Insert Node record with proper default values
                db.run(`
                    INSERT INTO Node (
                        NodeUuid, NodeName, NodeLock, NodeHidden,
                        NodeInputOp, NodeOutputOp, NodeRangeOp,
                        NodeIcon, NodeIconColor,
                        NodeNextUuid, NodeVariantID, NodeInitVariantID
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                `, [
                    nodeUuid,
                    brush.name,
                    0,  // NodeLock: 0 = unlocked
                    0,  // NodeHidden: 0 = visible
                    10, // NodeInputOp: 10 (default)
                    10, // NodeOutputOp: 10 (default)
                    0,  // NodeRangeOp: 0 (default)
                    128, // NodeIcon: 128 (default brush icon)
                    0,  // NodeIconColor: 0 (default)
                    null,  // NodeNextUuid: will be updated for previous node
                    variantId,
                    initVariantId
                ]);
                
                // Link previous node to this one
                if (prevNodeUuid) {
                    db.run(`
                        UPDATE Node SET NodeNextUuid = ? WHERE NodeUuid = ?
                    `, [nodeUuid, prevNodeUuid]);
                }
                
                prevNodeUuid = nodeUuid;
                convertedBrushes.push(brush);
                
                // Update progress
                const progress = Math.round(((i + 1) / AppState.brushes.length) * 100);
                UI.showProgress(progress);
                UI.showStatus(`Converting brush ${i + 1}/${AppState.brushes.length}: ${brush.name}`, 'info');
                
            } catch (error) {
                Logger.error(`Failed to convert ${brush.name}: ${error.message}`);
                failedBrushes.push({ name: brush.name, error: error.message });
            }
        }
        
        // Update root node to point to first brush
        if (firstBrushUuid) {
            db.run(`
                UPDATE Node SET NodeFirstChildUuid = ? WHERE NodeUuid = ?
            `, [firstBrushUuid, rootUuid]);
        }
        
        // Update Manager with MaxVariantID
        db.run(`
            UPDATE Manager SET MaxVariantID = ? WHERE _PW_ID = 1
        `, [variantIdCounter]);
        
        // Update stats
        AppState.stats.brushesConverted = convertedBrushes.length;
        AppState.stats.brushesValidated = convertedBrushes.length;
        UI.updateStats();
        UI.showFailedBrushes(failedBrushes);
        
        if (convertedBrushes.length === 0) {
            throw new Error('No brushes were successfully converted');
        }
        
        // Export database
        const dbData = db.export();
        const blob = new Blob([dbData], { type: 'application/x-sqlite3' });
        
        // Download
        const filename = `${packageName.replace(/[^a-zA-Z0-9]/g, '_')}.sut`;
        const url = URL.createObjectURL(blob);
        MemoryManager.addBlobUrl(url);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        
        Logger.success(`SUT file created with CORRECT CSP schema: ${filename} (${convertedBrushes.length} brushes)`);
        UI.showStatus(`Successfully created ${filename}`, 'success');
    },
    
    async convertToPNG() {
        Logger.info('Exporting brush tip PNGs...');
        
        const zip = new JSZip();
        const packageName = UI.sanitizeName(document.getElementById('packageName').value);
        let exportedCount = 0;
        
        for (let i = 0; i < AppState.brushes.length; i++) {
            const brush = AppState.brushes[i];
            
            try {
                // Check for abort
                if (AppState.abortController.signal.aborted) {
                    throw new Error('Export aborted');
                }
                
                if (brush.tipPNGs && brush.tipPNGs.length > 0) {
                    const response = await fetch(brush.tipPNGs[0]);
                    const blob = await response.blob();
                    
                    zip.file(`${brush.name}.png`, blob);
                    exportedCount++;
                }
                
                // Update progress
                const progress = Math.round(((i + 1) / AppState.brushes.length) * 100);
                UI.showProgress(progress);
                UI.showStatus(`Exporting PNG ${i + 1}/${AppState.brushes.length}: ${brush.name}`, 'info');
                
            } catch (error) {
                Logger.error(`Failed to export ${brush.name}: ${error.message}`);
            }
        }
        
        if (exportedCount === 0) {
            throw new Error('No PNG files to export');
        }
        
        // Generate ZIP
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        
        // Download
        const filename = `${packageName.replace(/[^a-zA-Z0-9]/g, '_')}_tips.zip`;
        const url = URL.createObjectURL(zipBlob);
        MemoryManager.addBlobUrl(url);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        
        AppState.stats.brushesConverted = exportedCount;
        UI.updateStats();
        
        Logger.success(`ZIP created: ${filename} (${exportedCount} PNGs)`);
        UI.showStatus(`Successfully exported ${exportedCount} PNG files`, 'success');
    },
    
    async runDebugConversion() {
        Logger.info('Running debug analysis...');
        
        const results = {
            totalBrushes: AppState.brushes.length,
            imageBrushes: 0,
            abrBrushes: 0,
            totalSize: 0,
            averageSize: 0,
            settings: {}
        };
        
        // Analyze brushes
        for (const brush of AppState.brushes) {
            if (brush.type === 'image') {
                results.imageBrushes++;
            } else if (brush.type === 'abr') {
                results.abrBrushes++;
            }
            
            results.totalSize += (brush.width || 0) * (brush.height || 0);
        }
        
        results.averageSize = results.imageBrushes > 0 ? Math.round(results.totalSize / results.imageBrushes) : 0;
        
        // Collect settings
        const settingsKeys = Object.keys(AppState.brushes[0]?.settings || {});
        for (const key of settingsKeys) {
            results.settings[key] = {
                min: Math.min(...AppState.brushes.map(b => b.settings[key] || 0)),
                max: Math.max(...AppState.brushes.map(b => b.settings[key] || 0)),
                avg: Math.round(AppState.brushes.reduce((sum, b) => sum + (b.settings[key] || 0), 0) / AppState.brushes.length)
            };
        }
        
        // Display results
        const debugResults = UI.elements.debugResults;
        debugResults.style.display = 'block';
        debugResults.innerHTML = `
            <strong>üìä Debug Analysis Results:</strong><br><br>
            Total Brushes: ${results.totalBrushes}<br>
            Image Brushes: ${results.imageBrushes}<br>
            ABR Brushes: ${results.abrBrushes}<br>
            Average Size: ${results.averageSize}x${results.averageSize}<br>
            <br><strong>Settings Analysis:</strong><br>
            ${Object.entries(results.settings).map(([key, values]) => 
                `${key}: Min=${values.min}, Max=${values.max}, Avg=${values.avg}<br>`
            ).join('')}
        `;
        
        Logger.success('Debug analysis completed');
        UI.showStatus('Debug analysis completed', 'success');
    }
};
</script>
</body>
</html>
