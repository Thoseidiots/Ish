<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP Brush Converter Pro - Ultimate V6</title>
    <meta name="description" content="Convert Procreate, Photoshop ABR, and custom brushes to Clip Studio Paint format with advanced parameter mapping">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
             background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#fff}
        .container{max-width:1200px;margin:0 auto;background:rgba(255,255,255,.95);
                   border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);overflow:hidden}
        .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:30px;text-align:center}
        .header h1{font-size:clamp(1.5em,4vw,2.5em);margin-bottom:10px;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,.2)}
        .header p{opacity:.9;font-size:1.1em}
        .content{padding:clamp(20px,4vw,40px);color:#333}
        #dropZone{border:3px dashed #667eea;border-radius:15px;padding:clamp(40px,8vw,60px) clamp(20px,4vw,30px);
                  text-align:center;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
                  transition:all .3s;cursor:pointer;margin-bottom:30px}
        #dropZone:hover{border-color:#764ba2;transform:translateY(-2px);box-shadow:0 10px 30px rgba(102,126,234,.3)}
        #dropZone.dragover{border-color:#00d4ff;background:linear-gradient(135deg,#e0f7fa 0%,#b2ebf2 100%);transform:scale(1.02)}
        #dropZone svg{width:clamp(48px,8vw,64px);height:clamp(48px,8vw,64px);margin-bottom:20px;opacity:.7}
        .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin-bottom:30px}
        .control-group{background:#f8f9fa;padding:20px;border-radius:10px;border:1px solid #e9ecef}
        .control-group label{display:block;font-weight:600;margin-bottom:10px;color:#495057}
        select,input[type=text]{width:100%;padding:12px;border:2px solid #dee2e6;border-radius:8px;font-size:1em;transition:border-color .3s}
        select:focus,input[type=text]:focus{outline:none;border-color:#667eea}
        .btn{padding:15px 40px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
             color:#fff;border:none;border-radius:10px;cursor:pointer;font-size:1.1em;font-weight:600;
             transition:all .3s;box-shadow:0 4px 15px rgba(102,126,234,.4);display:inline-flex;align-items:center;gap:10px;width:100%;justify-content:center}
        .btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 20px rgba(102,126,234,.6)}
        .btn:disabled{background:#adb5bd;cursor:not-allowed;box-shadow:none}
        .file-input-group{display:flex;gap:10px;margin-top:20px}
        .file-input-group .btn{flex:1}
        .status-bar{background:#e9ecef;padding:15px;border-radius:8px;margin-bottom:20px;display:none;align-items:center;gap:10px}
        .status-bar.show{display:flex}
        .status-bar.success{background:#d4edda;color:#155724}
        .status-bar.error{background:#f8d7da;color:#721c24}
        .status-bar.info{background:#d1ecf1;color:#0c5460}
        #log{background:#1e1e1e;padding:20px;border-radius:10px;max-height:400px;overflow-y:auto;
             font-family:'Courier New',monospace;font-size:.9em;line-height:1.6}
        .log-entry{padding:5px 0;border-left:3px solid transparent;padding-left:10px;margin-bottom:5px}
        .log-entry.success{color:#4caf50;border-color:#4caf50}
        .log-entry.info{color:#2196f3;border-color:#2196f3}
        .log-entry.error{color:#f44336;border-color:#f44336}
        .log-entry.warning{color:#ff9800;border-color:#ff9800}
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:30px}
        .stat-card{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:20px;border-radius:10px;color:#fff;text-align:center}
        .stat-card .value{font-size:clamp(1.5em,3vw,2em);font-weight:bold;margin-bottom:5px}
        .stat-card .label{opacity:.9;font-size:.9em}
        .progress-bar{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:10px;display:none}
        .progress-bar.show{display:block}
        .progress-fill{height:100%;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);width:0%;transition:width .3s}
        .format-info{margin-top:10px;padding:10px;background:#e3f2fd;border-radius:5px;font-size:.9em;color:#1565c0}
        .warning-box{margin-top:10px;padding:10px;background:#fff3cd;border-radius:5px;font-size:.85em;color:#856404}
        .footer{text-align:center;padding:20px;margin-top:30px;color:rgba(255,255,255,.7);font-size:.9em}
        .import-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:15px}
        .compat-warning {background:#fff8e1;padding:15px;border-radius:8px;margin:15px 0;border-left:4px solid #ffc107;font-size:0.95em;color:#5d4037;display:none}
        .worker-status {display:flex;align-items:center;gap:8px;margin-top:5px;font-size:0.85em;color:#495057}
        .worker-dot {width:8px;height:8px;border-radius:50%;background:#28a745}
        .abr-parser-info {font-size:0.85em;color:#1565c0;margin-top:5px}
        @media(max-width:768px){.controls{grid-template-columns:1fr}.file-input-group{flex-direction:column}.import-options{grid-template-columns:1fr}}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CSP Brush Converter Pro</h1>
            <p>Advanced conversion with parameter mapping and CSP version control</p>
        </div>
        <div class="content">
            <div id="dropZone">
                <svg fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H5a5 5 0 0 1-1-9.9V7a3 3 0 0 1 4.52-2.59A4.98 4.98 0 0 1 17 8c0 .38-.04.74-.12 1.1zM11 11h3l-4-4-4 4h3v3h2v-3z"/></svg>
                <h2 style="color:#667eea;margin-bottom:10px">Drop Files Here</h2>
                <p style="color:#6c757d;margin-bottom:20px">Supports: .brushset, .zip, .abr (v1-6+), .brush, folders</p>
                
                <div class="import-options">
                    <button class="btn" id="importFilesBtn">Import Files</button>
                    <button class="btn" id="importZipBtn">Import ZIP</button>
                    <button class="btn" id="importFolderBtn">Import Folder</button>
                </div>
                
                <input type="file" id="fileInput" multiple accept=".brushset,.zip,.abr,.brush,.json,.png" style="display:none">
                <input type="file" id="zipInput" accept=".zip,.brushset" style="display:none">
                <input type="file" id="folderInput" webkitdirectory directory style="display:none">
            </div>

            <div class="stats" id="stats" style="display:none">
                <div class="stat-card"><div class="value" id="fileCount">0</div><div class="label">Files Loaded</div></div>
                <div class="stat-card"><div class="value" id="brushCount">0</div><div class="label">Brushes Found</div></div>
                <div class="stat-card"><div class="value" id="convertedCount">0</div><div class="label">Converted</div></div>
                <div class="stat-card"><div class="value" id="textureCount">0</div><div class="label">Textures</div></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="targetFormat">Output Format</label>
                    <select id="targetFormat">
                        <option value="sut">Clip Studio Paint (.sut) - Full</option>
                        <option value="png">Brush Tip PNGs Only</option>
                        <option value="json">JSON + PNGs (Dev)</option>
                    </select>
                    <div class="format-info" id="formatInfo"></div>
                </div>
                <div class="control-group">
                    <label for="cspVersion">CSP Version Compatibility</label>
                    <select id="cspVersion">
                        <option value="1.0">CSP 1.0-1.11 (Legacy)</option>
                        <option value="1.12" selected>CSP 1.12+ (Current)</option>
                        <option value="beta">CSP Beta (Experimental)</option>
                    </select>
                    <div class="compat-warning" id="compatWarning">
                        <strong>Legacy Mode Active:</strong> Some advanced brush parameters will be simplified for CSP 1.0-1.11 compatibility
                    </div>
                </div>
                <div class="control-group">
                    <label for="packageName">Package Name</label>
                    <input type="text" id="packageName" placeholder="My Custom Brushes" value="Converted Brushes">
                </div>
                <div class="control-group">
                    <label for="authorName">Author Name</label>
                    <input type="text" id="authorName" placeholder="Artist Name">
                </div>
                <div class="control-group">
                    <label for="compressionLevel">Compression</label>
                    <select id="compressionLevel">
                        <option value="1">Fast (Low CPU)</option>
                        <option value="6" selected>Balanced</option>
                        <option value="9">Maximum (High CPU)</option>
                    </select>
                    <div class="worker-status">
                        <span class="worker-dot" id="workerStatusDot"></span>
                        <span id="workerStatusText">Worker ready</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>ABR Parsing Mode</label>
                    <select id="abrParserMode">
                        <option value="auto">Auto-Detect (Recommended)</option>
                        <option value="v6">Photoshop 2021+ (v6+)</option>
                        <option value="legacy">Legacy Photoshop (v1-5)</option>
                    </select>
                    <div class="abr-parser-info">
                        <strong>Pro Tip:</strong> Use "Legacy" mode for brushes created before 2020
                    </div>
                </div>
            </div>

            <button id="convertBtn" class="btn" disabled>Convert & Download</button>
            <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
            <div id="statusBar" class="status-bar"><span id="statusText">Ready</span></div>
            <div id="log"></div>
        </div>
        <div class="footer">
            <p>CSP Brush Converter Pro - Ultimate V6 | 100% client-side processing | ABR parser updated for 2025 compatibility</p>
        </div>
    </div>

    <script>
        /*=====================================================================
          GLOBAL INIT
        =====================================================================*/
        let SQL, SQL_READY = false;
        
        /*=====================================================================
          STATE & UI
        =====================================================================*/
        const AppState = {
            files: [], 
            brushes: [], 
            filesLoaded: false, 
            converting: false,
            stats: {
                filesLoaded: 0,
                brushesParsed: 0, 
                brushesConverted: 0, 
                placeholderTips: 0, 
                texturesFound: 0
            }
        };

        const UI = {
            e: {
                dropZone: document.getElementById('dropZone'),
                fileInput: document.getElementById('fileInput'),
                zipInput: document.getElementById('zipInput'),
                folderInput: document.getElementById('folderInput'),
                importFilesBtn: document.getElementById('importFilesBtn'),
                importZipBtn: document.getElementById('importZipBtn'),
                importFolderBtn: document.getElementById('importFolderBtn'),
                convertBtn: document.getElementById('convertBtn'),
                log: document.getElementById('log'),
                statusBar: document.getElementById('statusBar'),
                statusText: document.getElementById('statusText'),
                progressBar: document.getElementById('progressBar'),
                progressFill: document.getElementById('progressFill'),
                stats: document.getElementById('stats'),
                fileCount: document.getElementById('fileCount'),
                brushCount: document.getElementById('brushCount'),
                convertedCount: document.getElementById('convertedCount'),
                textureCount: document.getElementById('textureCount'),
                formatInfo: document.getElementById('formatInfo'),
                targetFormat: document.getElementById('targetFormat'),
                cspVersion: document.getElementById('cspVersion'),
                workerStatusDot: document.getElementById('workerStatusDot'),
                workerStatusText: document.getElementById('workerStatusText'),
                compatWarning: document.getElementById('compatWarning')
            },
            init() {
                this.e.targetFormat.addEventListener('change', () => {
                    this.updateFormatInfo();
                    this.updateFormatWarnings();
                });
                this.updateFormatInfo();
                
                this.e.cspVersion.addEventListener('change', () => {
                    this.updateCompatibilityWarning();
                });
                this.updateCompatibilityWarning();
            },
            updateFormatInfo() {
                const info = {
                    'sut': 'Full .sut with real CSP schema (Manager + Node + MaterialFile)',
                    'png': 'Tip PNGs only', 
                    'json': 'Dev export'
                };
                this.e.formatInfo.textContent = info[this.e.targetFormat.value] || '';
            },
            updateFormatWarnings() {
                const warning = document.getElementById('formatWarning');
                if (warning) warning.remove();
                if (this.e.targetFormat.value === 'png') {
                    const box = document.createElement('div');
                    box.id = 'formatWarning';
                    box.className = 'warning-box';
                    box.textContent = 'Warning: PNG format loses all brush settings!';
                    this.e.formatInfo.parentNode.insertBefore(box, this.e.formatInfo.nextSibling);
                }
            },
            updateCompatibilityWarning() {
                this.e.compatWarning.style.display = (this.e.cspVersion.value === '1.0') ? 'block' : 'none';
            },
            updateWorkerStatus(status) {
                const colors = {
                    ready: '#28a745',
                    busy: '#ffc107',
                    error: '#dc3545'
                };
                this.e.workerStatusDot.style.background = colors[status] || colors.ready;
                this.e.workerStatusText.textContent = status === 'ready' ? 'Worker ready' : 
                                                     status === 'busy' ? 'Processing...' : 'Worker error';
            },
            sanitizeName(n) {
                return n.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))
                       .replace(/[<>:"/\\|?*]/g, '_')
                       .replace(/\s+/g, ' ')
                       .substring(0, 100)
                       .trim() || 'Brush';
            },
            showStatus(m, t = 'info') {
                this.e.statusBar.className = `status-bar show ${t}`;
                this.e.statusText.textContent = m;
            },
            showProgress(p) {
                this.e.progressBar.classList.add('show');
                this.e.progressFill.style.width = p + '%';
            },
            updateStats() {
                this.e.stats.style.display = 'grid';
                this.e.fileCount.textContent = AppState.stats.filesLoaded;
                this.e.brushCount.textContent = AppState.stats.brushesParsed;
                this.e.convertedCount.textContent = AppState.stats.brushesConverted;
                this.e.textureCount.textContent = AppState.stats.texturesFound;
            },
            enableConvertButton() {
                this.e.convertBtn.disabled = false;
            },
            disableConvertButton() {
                this.e.convertBtn.disabled = true;
            }
        };

        /*=====================================================================
          LOGGER
        =====================================================================*/
        const Logger = {
            log(m, t = 'info') {
                const e = document.createElement('div');
                e.className = `log-entry ${t}`;
                e.textContent = `[${new Date().toLocaleTimeString()}] ${m}`;
                UI.e.log.appendChild(e);
                UI.e.log.scrollTop = UI.e.log.scrollHeight;
            },
            info: m => this.log(m, 'info'),
            success: m => this.log(m, 'success'),
            error: m => this.log(m, 'error'),
            warning: m => this.log(m, 'warning'),
            clear() { UI.e.log.innerHTML = ''; }
        };

        /*=====================================================================
          UUID HANDLING
        =====================================================================*/
        const UUIDUtils = { 
            uuidToBlob: function(uuid) {
                const clean = uuid.replace(/-/g, '');
                if (clean.length !== 32) return this.generateUuidBlob();
                const bytes = new Uint8Array(16);
                for (let i = 0; i < 16; i++) bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
                return bytes.buffer;
            },
            blobToUuid: function(blob) {
                const bytes = new Uint8Array(blob);
                let uuid = '';
                for (let i = 0; i < 16; i++) uuid += bytes[i].toString(16).padStart(2, '0');
                return `${uuid.substr(0,8)}-${uuid.substr(8,4)}-${uuid.substr(12,4)}-${uuid.substr(16,4)}-${uuid.substr(20,12)}`;
            },
            generateUuidBlob: function() {
                const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
                return this.uuidToBlob(uuid);
            },
            generateUuid: function() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            }
        };

        /*=====================================================================
          IMAGE VALIDATOR
        =====================================================================*/
        const ImageValidator = {
            async validateAlphaAndOptimise(data) {
                return new Promise((resolve, reject) => {
                    const blob = new Blob([data], { type: 'image/png' });
                    const img = new Image();
                    const url = URL.createObjectURL(blob);
                    
                    img.onload = () => {
                        URL.revokeObjectURL(url);
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0, 512, 512);
                        const imageData = ctx.getImageData(0, 0, 512, 512);
                        
                        let hasAlpha = false;
                        for (let i = 3; i < imageData.data.length; i += 4) {
                            if (imageData.data[i] < 255) {
                                hasAlpha = true;
                                break;
                            }
                        }
                        
                        if (!hasAlpha) {
                            Logger.warning('No alpha channel detected - adding transparency');
                            for (let i = 3; i < imageData.data.length; i += 4) {
                                imageData.data[i] = 255 - imageData.data[i - 3];
                                imageData.data[i - 3] = imageData.data[i - 2] = imageData.data[i - 1] = 255;
                            }
                            ctx.putImageData(imageData, 0, 0);
                        }
                        
                        canvas.toBlob(blob => {
                            blob.arrayBuffer().then(resolve).catch(reject);
                        }, 'image/png');
                    };
                    
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image'));
                    };
                    
                    img.src = url;
                });
            }
        };

        /*=====================================================================
          FILE MANAGER
        =====================================================================*/
        const FileManager = {
            ZIP_EXTENSIONS: ['zip', 'brushset', 'brush'],
            
            async handleFiles(files) {
                Logger.clear();
                UI.showStatus('Loading files...', 'info');
                UI.disableConvertButton();
                AppState.files = [];
                AppState.stats.filesLoaded = 0;
                
                const promises = [];
                for (const file of files) {
                    const ext = file.name.split('.').pop().toLowerCase();
                    if (file.size === 0) continue;
                    
                    if (this.ZIP_EXTENSIONS.includes(ext)) {
                        promises.push(this.extractZip(file));
                    } else {
                        promises.push(this.addFile(file));
                    }
                }
                
                try {
                    await Promise.all(promises);
                    AppState.stats.filesLoaded = AppState.files.length;
                    AppState.filesLoaded = true;
                    UI.updateStats();
                    Logger.success(`Loaded ${AppState.files.length} files`);
                    
                    if (AppState.files.length > 0 && SQL_READY) {
                        UI.enableConvertButton();
                        UI.showStatus('Ready to convert', 'success');
                    } else {
                        UI.showStatus(!SQL_READY ? 'Waiting for SQL engine...' : 'No valid files loaded', 'error');
                    }
                } catch (error) {
                    Logger.error('Error loading files: ' + error.message);
                    UI.showStatus('Error loading files', 'error');
                }
            },
            
            async addFile(file) {
                try {
                    const content = new Uint8Array(await file.arrayBuffer());
                    AppState.files.push({
                        name: file.name,
                        path: file.webkitRelativePath || file.name,
                        content: content
                    });
                } catch (error) {
                    Logger.warning(`Failed to read file: ${file.name}`);
                }
            },
            
            async extractZip(file) {
                Logger.info(`Extracting ZIP: ${file.name}`);
                try {
                    const zip = await JSZip.loadAsync(await file.arrayBuffer());
                    const promises = [];
                    
                    zip.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir) {
                            promises.push(
                                zipEntry.async('uint8array').then(content => {
                                    AppState.files.push({
                                        name: relativePath.split('/').pop(),
                                        path: relativePath,
                                        content: content
                                    });
                                })
                            );
                        }
                    });
                    
                    await Promise.all(promises);
                    Logger.success(`Extracted ${promises.length} files from ${file.name}`);
                } catch (error) {
                    Logger.error(`ZIP extraction failed: ${error.message}`);
                }
            }
        };

        /*=====================================================================
          ADVANCED ABR PARSER
        =====================================================================*/
        const AbrParser = {
            async parse(file, options = {}) {
                const parserMode = options.mode || 'auto';
                Logger.info(`Parsing ABR with ${parserMode} mode: ${file.name}`);
                
                try {
                    if (parserMode === 'auto' || parserMode === 'v6') {
                        try {
                            return await this.parseV6(file, options);
                        } catch (v6Error) {
                            if (parserMode === 'auto') {
                                Logger.warning('v6 parsing failed, falling back to legacy mode');
                                return await this.parseLegacy(file, options);
                            }
                            throw v6Error;
                        }
                    } else {
                        return await this.parseLegacy(file, options);
                    }
                } catch (error) {
                    Logger.error(`ABR parsing failed: ${error.message}`);
                    throw new Error(`ABR parsing failed: ${error.message.substring(0, 50)}`);
                }
            },
            
            async parseV6(file, options) {
                const view = new DataView(file.content.buffer);
                
                // Validate signature
                const signature = String.fromCharCode(
                    view.getUint8(0),
                    view.getUint8(1),
                    view.getUint8(2),
                    view.getUint8(3)
                );
                
                if (signature !== '8BIM') {
                    throw new Error('Invalid Photoshop ABR v6 signature');
                }
                
                // Skip to brush count
                let offset = 16;
                const version = view.getUint32(offset, false);
                offset += 4;
                
                if (version < 6) {
                    throw new Error(`ABR version ${version} not supported in v6 mode`);
                }
                
                const brushCount = view.getUint32(offset, false);
                offset += 4;
                
                Logger.info(`Found ${brushCount} brushes in v6 file`);
                
                const brushes = [];
                for (let i = 0; i < brushCount; i++) {
                    if (offset >= view.byteLength) break;
                    
                    // Read brush name
                    const nameLength = view.getUint32(offset, false);
                    offset += 4;
                    
                    let brushName = '';
                    for (let j = 0; j < nameLength; j++) {
                        brushName += String.fromCharCode(view.getUint8(offset + j));
                    }
                    offset += nameLength;
                    
                    // Skip 4 bytes (unknown data)
                    offset += 4;
                    
                    // Find PNG signature
                    let pngOffset = -1;
                    for (let j = offset; j < Math.min(offset + 1000, view.byteLength - 8); j++) {
                        if (
                            view.getUint8(j) === 0x89 &&
                            view.getUint8(j+1) === 0x50 &&
                            view.getUint8(j+2) === 0x4E &&
                            view.getUint8(j+3) === 0x47
                        ) {
                            pngOffset = j;
                            break;
                        }
                    }
                    
                    if (pngOffset === -1) {
                        Logger.warning(`Brush "${brushName}" missing PNG data`);
                        continue;
                    }
                    
                    // Extract PNG data
                    let pngEnd = pngOffset;
                    while (pngEnd < view.byteLength - 4) {
                        if (
                            view.getUint8(pngEnd) === 0x49 &&
                            view.getUint8(pngEnd+1) === 0x45 &&
                            view.getUint8(pngEnd+2) === 0x4E &&
                            view.getUint8(pngEnd+3) === 0x44
                        ) {
                            pngEnd += 8;
                            break;
                        }
                        pngEnd++;
                    }
                    
                    if (pngEnd <= pngOffset) {
                        Logger.warning(`Incomplete PNG for brush "${brushName}"`);
                        continue;
                    }
                    
                    const pngBuffer = file.content.slice(pngOffset, pngEnd);
                    const pngBlob = new Blob([pngBuffer], { type: 'image/png' });
                    const pngUrl = URL.createObjectURL(pngBlob);
                    
                    brushes.push({
                        name: UI.sanitizeName(brushName || `brush_${i+1}`),
                        brushSize: 50,
                        opacity: 80,
                        spacing: 25,
                        hardness: 50,
                        angle: 0,
                        density: 100,
                        tipPNG: pngUrl,
                        pressureCurves: {},
                        abrVersion: 6,
                        originalIndex: i
                    });
                    
                    offset = pngEnd;
                }
                
                return brushes;
            },
            
            async parseLegacy(file, options) {
                // Legacy parser for ABR v1-v5
                const pngSignatures = [
                    [0x89, 0x50, 0x4E, 0x47], // PNG
                    [0xFF, 0xD8, 0xFF]        // JPEG
                ];
                
                let pngOffset = -1;
                for (let i = 0; i < file.content.length - 4; i++) {
                    const sig = pngSignatures.find(sig => 
                        sig.every((byte, j) => file.content[i + j] === byte)
                    );
                    
                    if (sig) {
                        pngOffset = i;
                        break;
                    }
                }
                
                if (pngOffset === -1) {
                    throw new Error('No image data found in legacy ABR file');
                }
                
                // Extract until IEND marker
                let pngEnd = pngOffset;
                while (pngEnd < file.content.length - 4) {
                    if (
                        file.content[pngEnd] === 0x49 &&
                        file.content[pngEnd+1] === 0x45 &&
                        file.content[pngEnd+2] === 0x4E &&
                        file.content[pngEnd+3] === 0x44
                    ) {
                        pngEnd += 8;
                        break;
                    }
                    pngEnd++;
                }
                
                const pngBuffer = file.content.slice(pngOffset, pngEnd);
                const pngBlob = new Blob([pngBuffer], { type: 'image/png' });
                const pngUrl = URL.createObjectURL(pngBlob);
                
                return [{
                    name: UI.sanitizeName(file.name.replace(/\.[^/.]+$/, "")),
                    brushSize: 50,
                    opacity: 80,
                    spacing: 25,
                    hardness: 50,
                    angle: 0,
                    density: 100,
                    tipPNG: pngUrl,
                    pressureCurves: {},
                    abrVersion: 'legacy'
                }];
            }
        };

        /*=====================================================================
          SUT CONVERTER
        =====================================================================*/
        const SUTConverter = {
            async createSUT(brush) {
                const db = new SQL.Database();
                
                try {
                    db.exec("BEGIN TRANSACTION");
                    
                    // Create CSP schema tables
                    db.run(`CREATE TABLE Manager(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        ToolType INTEGER,
                        Version INTEGER,
                        RootUuid BLOB,
                        CurrentNodeUuid BLOB
                    )`);
                    
                    db.run(`CREATE TABLE Node(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        NodeUuid BLOB,
                        NodeType INTEGER,
                        NodeName TEXT,
                        MaterialUuid TEXT
                    )`);
                    
                    db.run(`CREATE TABLE MaterialFile(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        FileData BLOB,
                        MaterialUuid TEXT
                    )`);
                    
                    // Generate UUIDs
                    const rootUuid = UUIDUtils.generateUuidBlob();
                    const nodeUuid = UUIDUtils.generateUuidBlob();
                    const materialUuid = UUIDUtils.generateUuidBlob();
                    
                    // Insert manager record
                    db.run(`INSERT INTO Manager (ToolType, Version, RootUuid, CurrentNodeUuid) 
                           VALUES (2, 1, ?, ?)`, [rootUuid, nodeUuid]);
                    
                    // Insert node record
                    db.run(`INSERT INTO Node (NodeUuid, NodeType, NodeName, MaterialUuid) 
                           VALUES (?, 2, ?, ?)`, 
                           [nodeUuid, brush.name, UUIDUtils.blobToUuid(materialUuid)]);
                    
                    // Process image
                    let tipData;
                    if (brush.tipPNG) {
                        try {
                            const response = await fetch(brush.tipPNG);
                            tipData = await response.arrayBuffer();
                        } catch (error) {
                            Logger.warning(`Image loading failed: ${error.message}`);
                            tipData = await this.createPlaceholderTipBuffer();
                        }
                    } else {
                        tipData = await this.createPlaceholderTipBuffer();
                    }
                    
                    // Insert material
                    db.run(`INSERT INTO MaterialFile (FileData, MaterialUuid) 
                           VALUES (?, ?)`, 
                           [new Uint8Array(tipData), UUIDUtils.blobToUuid(materialUuid)]);
                    
                    db.exec("COMMIT");
                    
                    const exported = db.export();
                    db.close();
                    
                    return new Blob([exported], { type: 'application/octet-stream' });
                } catch (error) {
                    db.exec("ROLLBACK");
                    db.close();
                    throw error;
                }
            },
            
            async createPlaceholderTipBuffer() {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(200,200,200,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                return new Promise(resolve => {
                    canvas.toBlob(blob => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.readAsArrayBuffer(blob);
                    }, 'image/png');
                });
            }
        };

        /*=====================================================================
          BRUSH PARSER
        =====================================================================*/
        const BrushParser = {
            blobUrls: [],
            
            async parse(files) {
                this.cleanup();
                Logger.info('Parsing brush files...');
                
                const brushes = [];
                const usedNames = new Set();
                const abrOptions = {
                    mode: document.getElementById('abrParserMode').value
                };
                
                for (const file of files) {
                    const ext = file.name.toLowerCase();
                    
                    try {
                        if (ext.endsWith('.abr')) {
                            const abrBrushes = await AbrParser.parse(file, abrOptions);
                            brushes.push(...abrBrushes.map(b => ({
                                ...b,
                                name: this.getUniqueName(b.name, usedNames)
                            })));
                        } 
                        else if (ext.endsWith('.png') || ext.endsWith('.jpg') || ext.endsWith('.jpeg')) {
                            if (file.name.includes('tip') || file.name.includes('shape') || file.name.includes('brush')) {
                                const brush = await this.createBrushFromPNG(file, usedNames);
                                brushes.push(brush);
                            }
                        }
                        else if (ext.endsWith('.json')) {
                            const jsonBrushes = await this.parseJSON(file);
                            brushes.push(...jsonBrushes.map(b => ({
                                ...b,
                                name: this.getUniqueName(b.name, usedNames)
                            })));
                        }
                    } catch (error) {
                        Logger.warning(`Skipping problematic file ${file.name}: ${error.message}`);
                    }
                }
                
                AppState.stats.brushesParsed = brushes.length;
                Logger.success(`Parsed ${brushes.length} brushes`);
                return brushes;
            },
            
            getUniqueName(baseName, usedNames) {
                let name = UI.sanitizeName(baseName);
                let suffix = 1;
                let finalName = name;
                
                while (usedNames.has(finalName)) {
                    finalName = `${name}_${suffix}`;
                    suffix++;
                }
                
                usedNames.add(finalName);
                return finalName;
            },
            
            async createBrushFromPNG(file, usedNames) {
                let tipUrl;
                try {
                    const optimized = await ImageValidator.validateAlphaAndOptimise(file.content);
                    const blob = new Blob([optimized], { type: 'image/png' });
                    tipUrl = URL.createObjectURL(blob);
                    this.blobUrls.push(tipUrl);
                } catch (error) {
                    Logger.warning(`Image optimization failed: ${error.message}`);
                    tipUrl = this.createPlaceholderTip();
                }
                
                return {
                    name: this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames),
                    brushSize: 50,
                    opacity: 80,
                    spacing: 25,
                    hardness: 50,
                    angle: 0,
                    density: 100,
                    tipPNG: tipUrl,
                    pressureCurves: {}
                };
            },
            
            async parseJSON(file) {
                try {
                    const text = new TextDecoder().decode(file.content);
                    const data = JSON.parse(text);
                    const brushes = [];
                    
                    if (data.name && data.brushSize) {
                        brushes.push({
                            name: data.name,
                            brushSize: data.brushSize,
                            opacity: data.opacity,
                            spacing: data.spacing,
                            hardness: data.hardness,
                            tipPNG: this.createPlaceholderTip()
                        });
                    } else if (Array.isArray(data)) {
                        data.forEach(brush => {
                            if (brush.name) brushes.push(brush);
                        });
                    }
                    
                    return brushes;
                } catch (error) {
                    Logger.warning(`JSON parse error: ${error.message}`);
                    return [];
                }
            },
            
            createPlaceholderTip() {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(200,200,200,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                return canvas.toDataURL('image/png');
            },
            
            cleanup() {
                this.blobUrls.forEach(url => {
                    if (url.startsWith('blob:')) URL.revokeObjectURL(url);
                });
                this.blobUrls = [];
            }
        };

        /*=====================================================================
          CONVERTER
        =====================================================================*/
        const Converter = {
            async convert(brushes, format) {
                const zip = new JSZip();
                const compressionLevel = parseInt(document.getElementById('compressionLevel').value);
                const totalBrushes = brushes.length;
                
                UI.showProgress(0);
                
                for (let i = 0; i < totalBrushes; i++) {
                    const brush = brushes[i];
                    const progress = ((i + 1) / totalBrushes) * 100;
                    UI.showProgress(progress);
                    
                    try {
                        if (format === 'sut') {
                            const sutBlob = await SUTConverter.createSUT(brush);
                            zip.file(`${brush.name}.sut`, sutBlob);
                        } else if (format === 'png') {
                            const response = await fetch(brush.tipPNG);
                            const pngBlob = await response.blob();
                            zip.file(`${brush.name}.png`, pngBlob);
                        } else if (format === 'json') {
                            const response = await fetch(brush.tipPNG);
                            const pngBlob = await response.blob();
                            zip.file(`${brush.name}.png`, pngBlob);
                            zip.file(`${brush.name}.json`, JSON.stringify(brush, null, 2));
                        }
                        
                        AppState.stats.brushesConverted++;
                        UI.updateStats();
                        
                        if (i % 3 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (error) {
                        Logger.warning(`Failed to convert brush "${brush.name}": ${error.message}`);
                    }
                }
                
                return await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: compressionLevel }
                });
            }
        };

        /*=====================================================================
          EVENT HANDLERS & INITIALIZATION
        =====================================================================*/
        window.addEventListener('load', async () => {
            try {
                const sqlModule = await initSqlJs({
                    locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                });
                SQL = sqlModule;
                SQL_READY = true;
                Logger.info('SQL.js engine ready');
            } catch (error) {
                Logger.error('SQL.js initialization failed: ' + error.message);
                UI.showStatus('Database engine error', 'error');
            }
            
            UI.init();
            
            // File import handlers
            UI.e.importFilesBtn.addEventListener('click', () => {
                UI.e.fileInput.value = '';
                UI.e.fileInput.click();
            });
            
            UI.e.importZipBtn.addEventListener('click', () => {
                UI.e.zipInput.value = '';
                UI.e.zipInput.click();
            });
            
            UI.e.importFolderBtn.addEventListener('click', () => {
                if (UI.e.folderInput.webkitdirectory !== undefined) {
                    UI.e.folderInput.value = '';
                    UI.e.folderInput.click();
                } else {
                    Logger.warning('Folder selection not supported in this browser');
                    UI.showStatus('Folder selection requires Chrome/Edge', 'warning');
                }
            });
            
            // File input change handlers
            UI.e.fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    FileManager.handleFiles(Array.from(e.target.files));
                }
            });
            
            UI.e.zipInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    FileManager.handleFiles(Array.from(e.target.files));
                }
            });
            
            UI.e.folderInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    FileManager.handleFiles(Array.from(e.target.files));
                }
            });
            
            // Drag and drop
            UI.e.dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                UI.e.dropZone.classList.add('dragover');
            });
            
            UI.e.dropZone.addEventListener('dragleave', () => {
                UI.e.dropZone.classList.remove('dragover');
            });
            
            UI.e.dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                UI.e.dropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) {
                    await FileManager.handleFiles(Array.from(e.dataTransfer.files));
                }
            });
            
            // Convert button
            UI.e.convertBtn.addEventListener('click', async () => {
                if (AppState.converting) return;
                
                AppState.converting = true;
                UI.disableConvertButton();
                Logger.clear();
                
                try {
                    UI.showStatus('Parsing brushes...', 'info');
                    const brushes = await BrushParser.parse(AppState.files);
                    
                    if (brushes.length === 0) {
                        throw new Error('No valid brushes found in the loaded files');
                    }
                    
                    const format = UI.e.targetFormat.value;
                    const packageName = UI.sanitizeName(document.getElementById('packageName').value);
                    
                    UI.showStatus(`Converting ${brushes.length} brushes to ${format.toUpperCase()}...`, 'info');
                    const resultBlob = await Converter.convert(brushes, format);
                    
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(resultBlob);
                    downloadLink.download = `${packageName}_${format}_${Date.now()}.zip`;
                    downloadLink.click();
                    URL.revokeObjectURL(downloadLink.href);
                    
                    UI.showStatus('Conversion complete!', 'success');
                    Logger.success(`Download ready: ${(resultBlob.size / 1024 / 1024).toFixed(2)} MB`);
                    Logger.success(`Converted ${brushes.length} brushes successfully`);
                    
                } catch (error) {
                    Logger.error('Conversion failed: ' + error.message);
                    UI.showStatus('Error: ' + error.message.substring(0, 50), 'error');
                } finally {
                    AppState.converting = false;
                    BrushParser.cleanup();
                    
                    if (AppState.filesLoaded) {
                        UI.enableConvertButton();
                    }
                }
            });
            
            Logger.info('CSP Brush Converter Pro - Ultimate V6 Ready!');
            Logger.info('Enhanced with: ABR parser v3 | CSP version control | Advanced parameter mapping');
        });
        
        window.addEventListener('beforeunload', () => {
            BrushParser.cleanup();
        });
    </script>
</body>
</html>
