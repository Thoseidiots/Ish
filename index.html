<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP Brush Converter Pro - Fully Working Version</title>
    <meta name="description" content="Convert Procreate, Photoshop ABR, and custom brushes to Clip Studio Paint format">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
             background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#fff}
        .container{max-width:1200px;margin:0 auto;background:rgba(255,255,255,.95);
                   border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);overflow:hidden}
        .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:30px;text-align:center}
        .header h1{font-size:clamp(1.5em,4vw,2.5em);margin-bottom:10px;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,.2)}
        .header p{opacity:.9;font-size:1.1em}
        .content{padding:clamp(20px,4vw,40px);color:#333}
        #dropZone{border:3px dashed #667eea;border-radius:15px;padding:clamp(40px,8vw,60px) clamp(20px,4vw,30px);
                  text-align:center;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
                  transition:all .3s;cursor:pointer;margin-bottom:30px}
        #dropZone:hover{border-color:#764ba2;transform:translateY(-2px);box-shadow:0 10px 30px rgba(102,126,234,.3)}
        #dropZone.dragover{border-color:#00d4ff;background:linear-gradient(135deg,#e0f7fa 0%,#b2ebf2 100%);transform:scale(1.02)}
        #dropZone svg{width:clamp(48px,8vw,64px);height:clamp(48px,8vw,64px);margin-bottom:20px;opacity:.7}
        .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin-bottom:30px}
        .control-group{background:#f8f9fa;padding:20px;border-radius:10px;border:1px solid #e9ecef}
        .control-group label{display:block;font-weight:600;margin-bottom:10px;color:#495057}
        select,input[type=text]{width:100%;padding:12px;border:2px solid #dee2e6;border-radius:8px;font-size:1em;transition:border-color .3s}
        select:focus,input[type=text]:focus{outline:none;border-color:#667eea}
        .btn{padding:15px 40px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
             color:#fff;border:none;border-radius:10px;cursor:pointer;font-size:1.1em;font-weight:600;
             transition:all .3s;box-shadow:0 4px 15px rgba(102,126,234,.4);display:inline-flex;align-items:center;gap:10px;width:100%;justify-content:center}
        .btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 20px rgba(102,126,234,.6)}
        .btn:disabled{background:#adb5bd;cursor:not-allowed;box-shadow:none}
        .status-bar{background:#e9ecef;padding:15px;border-radius:8px;margin-bottom:20px;display:none;align-items:center;gap:10px}
        .status-bar.show{display:flex}
        .status-bar.success{background:#d4edda;color:#155724}
        .status-bar.error{background:#f8d7da;color:#721c24}
        .status-bar.info{background:#d1ecf1;color:#0c5460}
        #log{background:#1e1e1e;padding:20px;border-radius:10px;max-height:400px;overflow-y:auto;
             font-family:'Courier New',monospace;font-size:.9em;line-height:1.6}
        .log-entry{padding:5px 0;border-left:3px solid transparent;padding-left:10px;margin-bottom:5px}
        .log-entry.success{color:#4caf50;border-color:#4caf50}
        .log-entry.info{color:#2196f3;border-color:#2196f3}
        .log-entry.error{color:#f44336;border-color:#f44336}
        .log-entry.warning{color:#ff9800;border-color:#ff9800}
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:30px}
        .stat-card{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:20px;border-radius:10px;color:#fff;text-align:center}
        .stat-card .value{font-size:clamp(1.5em,3vw,2em);font-weight:bold;margin-bottom:5px}
        .stat-card .label{opacity:.9;font-size:.9em}
        .progress-bar{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:10px;display:none}
        .progress-bar.show{display:block}
        .progress-fill{height:100%;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);width:0%;transition:width .3s}
        .format-info{margin-top:10px;padding:10px;background:#e3f2fd;border-radius:5px;font-size:.9em;color:#1565c0}
        .import-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:15px}
        .preview-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:10px;margin-top:20px}
        .preview-item{text-align:center}
        .preview-item img{width:100%;height:100px;object-fit:contain;border:1px solid #dee2e6;border-radius:5px;background:#fff}
        .preview-item p{font-size:.8em;margin-top:5px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .footer{text-align:center;padding:20px;margin-top:30px;color:rgba(255,255,255,.7);font-size:.9em}
        @media(max-width:768px){.controls{grid-template-columns:1fr}.import-options{grid-template-columns:1fr}}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CSP Brush Converter Pro</h1>
            <p>Fully Working Version - Converts Real Images</p>
        </div>
        <div class="content">
            <div id="dropZone">
                <svg fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H5a5 5 0 0 1-1-9.9V7a3 3 0 0 1 4.52-2.59A4.98 4.98 0 0 1 17 8c0 .38-.04.74-.12 1.1zM11 11h3l-4-4-4 4h3v3h2v-3z"/></svg>
                <h2 style="color:#667eea;margin-bottom:10px">Drop Files Here</h2>
                <p style="color:#6c757d;margin-bottom:20px">Supports: PNG, ABR, ZIP files containing brushes</p>
                
                <div class="import-options">
                    <button class="btn" id="importFilesBtn">Import Files</button>
                    <button class="btn" id="importZipBtn">Import ZIP</button>
                </div>
                
                <input type="file" id="fileInput" multiple accept=".png,.abr,.zip" style="display:none">
                <input type="file" id="zipInput" accept=".zip" style="display:none">
            </div>

            <div class="stats" id="stats" style="display:none">
                <div class="stat-card"><div class="value" id="fileCount">0</div><div class="label">Files Loaded</div></div>
                <div class="stat-card"><div class="value" id="brushCount">0</div><div class="label">Brushes Found</div></div>
                <div class="stat-card"><div class="value" id="convertedCount">0</div><div class="label">Converted</div></div>
            </div>

            <div id="previewContainer" style="display:none;margin-bottom:20px;">
                <h3 style="margin-bottom:10px;color:#495057;">Brush Preview</h3>
                <div id="previewGrid" class="preview-grid"></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="targetFormat">Output Format</label>
                    <select id="targetFormat">
                        <option value="sut">Clip Studio Paint (.sut)</option>
                        <option value="png">Brush Tip PNGs Only</option>
                    </select>
                    <div class="format-info" id="formatInfo"></div>
                </div>
                <div class="control-group">
                    <label for="packageName">Package Name</label>
                    <input type="text" id="packageName" placeholder="My Custom Brushes" value="Converted Brushes">
                </div>
                <div class="control-group">
                    <label for="compressionLevel">Compression</label>
                    <select id="compressionLevel">
                        <option value="1">Fast</option>
                        <option value="6" selected>Balanced</option>
                        <option value="9">Maximum</option>
                    </select>
                </div>
            </div>

            <button id="convertBtn" class="btn" disabled>Convert & Download</button>
            <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
            <div id="statusBar" class="status-bar"><span id="statusText">Ready</span></div>
            <div id="log"></div>
        </div>
        <div class="footer">
            <p>CSP Brush Converter Pro - Fully Working Version | All processing happens in your browser</p>
        </div>
    </div>

    <script>
        // Global variables
        let SQL, SQL_READY = false;
        
        // Application state
        const AppState = {
            files: [],
            brushes: [],
            filesLoaded: false,
            converting: false,
            stats: {
                filesLoaded: 0,
                brushesParsed: 0,
                brushesConverted: 0
            }
        };

        // UI management
        const UI = {
            elements: {
                dropZone: document.getElementById('dropZone'),
                fileInput: document.getElementById('fileInput'),
                zipInput: document.getElementById('zipInput'),
                importFilesBtn: document.getElementById('importFilesBtn'),
                importZipBtn: document.getElementById('importZipBtn'),
                convertBtn: document.getElementById('convertBtn'),
                log: document.getElementById('log'),
                statusBar: document.getElementById('statusBar'),
                statusText: document.getElementById('statusText'),
                progressBar: document.getElementById('progressBar'),
                progressFill: document.getElementById('progressFill'),
                stats: document.getElementById('stats'),
                fileCount: document.getElementById('fileCount'),
                brushCount: document.getElementById('brushCount'),
                convertedCount: document.getElementById('convertedCount'),
                targetFormat: document.getElementById('targetFormat'),
                formatInfo: document.getElementById('formatInfo'),
                previewContainer: document.getElementById('previewContainer'),
                previewGrid: document.getElementById('previewGrid')
            },
            
            init() {
                // Format info update
                this.elements.targetFormat.addEventListener('change', () => {
                    const info = {
                        'sut': 'Full CSP brush files with metadata',
                        'png': 'Brush tip images only'
                    };
                    this.elements.formatInfo.textContent = info[this.elements.targetFormat.value] || '';
                });
                
                // Set up event listeners
                this.elements.importFilesBtn.addEventListener('click', () => this.elements.fileInput.click());
                this.elements.importZipBtn.addEventListener('click', () => this.elements.zipInput.click());
                
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) FileManager.handleFiles(Array.from(e.target.files));
                });
                
                this.elements.zipInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) FileManager.handleFiles(Array.from(e.target.files));
                });
                
                // Drag and drop
                this.elements.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.elements.dropZone.classList.add('dragover');
                });
                
                this.elements.dropZone.addEventListener('dragleave', () => {
                    this.elements.dropZone.classList.remove('dragover');
                });
                
                this.elements.dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.elements.dropZone.classList.remove('dragover');
                    if (e.dataTransfer.files.length > 0) {
                        FileManager.handleFiles(Array.from(e.dataTransfer.files));
                    }
                });
                
                // Convert button
                this.elements.convertBtn.addEventListener('click', Converter.convertAll);
                
                // Initialize format info
                this.elements.targetFormat.dispatchEvent(new Event('change'));
            },
            
            showStatus(message, type = 'info') {
                this.elements.statusBar.className = `status-bar show ${type}`;
                this.elements.statusText.textContent = message;
            },
            
            showProgress(percent) {
                this.elements.progressBar.classList.add('show');
                this.elements.progressFill.style.width = percent + '%';
            },
            
            updateStats() {
                this.elements.stats.style.display = 'grid';
                this.elements.fileCount.textContent = AppState.stats.filesLoaded;
                this.elements.brushCount.textContent = AppState.stats.brushesParsed;
                this.elements.convertedCount.textContent = AppState.stats.brushesConverted;
            },
            
            updatePreview(brushes) {
                this.elements.previewGrid.innerHTML = '';
                if (brushes.length === 0) {
                    this.elements.previewContainer.style.display = 'none';
                    return;
                }
                
                this.elements.previewContainer.style.display = 'block';
                brushes.slice(0, 12).forEach(brush => {
                    const item = document.createElement('div');
                    item.className = 'preview-item';
                    
                    const img = document.createElement('img');
                    img.src = brush.tipPNG;
                    img.alt = brush.name;
                    
                    const label = document.createElement('p');
                    label.textContent = brush.name;
                    label.title = brush.name;
                    
                    item.appendChild(img);
                    item.appendChild(label);
                    this.elements.previewGrid.appendChild(item);
                });
                
                if (brushes.length > 12) {
                    const more = document.createElement('div');
                    more.className = 'preview-item';
                    more.innerHTML = `<p style="text-align:center;padding-top:40px">+${brushes.length - 12} more</p>`;
                    this.elements.previewGrid.appendChild(more);
                }
            },
            
            enableConvertButton() {
                this.elements.convertBtn.disabled = false;
            },
            
            disableConvertButton() {
                this.elements.convertBtn.disabled = true;
            },
            
            sanitizeName(name) {
                return name.replace(/[<>:"/\\|?*]/g, '_')
                          .replace(/\s+/g, ' ')
                          .substring(0, 100)
                          .trim() || 'Brush';
            }
        };

        // Logging system
        const Logger = {
            log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                UI.elements.log.appendChild(entry);
                UI.elements.log.scrollTop = UI.elements.log.scrollHeight;
            },
            
            info(message) { this.log(message, 'info'); },
            success(message) { this.log(message, 'success'); },
            error(message) { this.log(message, 'error'); },
            warning(message) { this.log(message, 'warning'); },
            
            clear() {
                UI.elements.log.innerHTML = '';
            }
        };

        // File management
        const FileManager = {
            async handleFiles(files) {
                Logger.clear();
                UI.showStatus('Loading files...', 'info');
                UI.disableConvertButton();
                AppState.files = [];
                
                try {
                    for (const file of files) {
                        if (file.size === 0) continue;
                        
                        const ext = file.name.toLowerCase().split('.').pop();
                        if (ext === 'zip') {
                            await this.extractZip(file);
                        } else {
                            await this.addFile(file);
                        }
                    }
                    
                    AppState.stats.filesLoaded = AppState.files.length;
                    AppState.filesLoaded = true;
                    UI.updateStats();
                    Logger.success(`Loaded ${AppState.files.length} files`);
                    
                    if (AppState.files.length > 0) {
                        UI.enableConvertButton();
                        UI.showStatus('Ready to convert', 'success');
                    } else {
                        UI.showStatus('No valid files loaded', 'error');
                    }
                } catch (error) {
                    Logger.error('Failed to load files: ' + error.message);
                    UI.showStatus('Error loading files', 'error');
                }
            },
            
            async addFile(file) {
                try {
                    const content = new Uint8Array(await file.arrayBuffer());
                    AppState.files.push({
                        name: file.name,
                        content: content
                    });
                } catch (error) {
                    Logger.warning(`Failed to read file: ${file.name}`);
                }
            },
            
            async extractZip(file) {
                try {
                    const zip = await JSZip.loadAsync(await file.arrayBuffer());
                    const promises = [];
                    
                    zip.forEach((path, entry) => {
                        if (!entry.dir) {
                            promises.push(
                                entry.async('uint8array').then(content => {
                                    AppState.files.push({
                                        name: path.split('/').pop(),
                                        content: content
                                    });
                                })
                            );
                        }
                    });
                    
                    await Promise.all(promises);
                    Logger.success(`Extracted ${promises.length} files from ZIP`);
                } catch (error) {
                    Logger.error('ZIP extraction failed: ' + error.message);
                }
            }
        };

        // Image processor - ACTUAL IMAGE PROCESSING
        const ImageProcessor = {
            async processImage(imageData) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.onload = () => {
                        try {
                            // Resize to max 512x512 while maintaining aspect ratio
                            const maxSize = 512;
                            const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
                            canvas.width = img.width * scale;
                            canvas.height = img.height * scale;
                            
                            // Draw image
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            
                            // Check and handle alpha channel
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            let hasAlpha = false;
                            
                            for (let i = 3; i < imageData.data.length; i += 4) {
                                if (imageData.data[i] < 255) {
                                    hasAlpha = true;
                                    break;
                                }
                            }
                            
                            // If no alpha, create one based on luminance
                            if (!hasAlpha) {
                                for (let i = 0; i < imageData.data.length; i += 4) {
                                    const r = imageData.data[i];
                                    const g = imageData.data[i + 1];
                                    const b = imageData.data[i + 2];
                                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                                    
                                    // Keep original RGB but set alpha based on luminance
                                    imageData.data[i + 3] = 255 - Math.round(luminance * 0.8);
                                }
                                ctx.putImageData(imageData, 0, 0);
                            }
                            
                            // Convert to data URL
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    const reader = new FileReader();
                                    reader.onload = () => resolve(reader.result);
                                    reader.onerror = () => reject(new Error('Failed to read blob'));
                                    reader.readAsDataURL(blob);
                                } else {
                                    reject(new Error('Canvas to blob failed'));
                                }
                            }, 'image/png', 0.9);
                            
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    img.onerror = () => {
                        reject(new Error('Image loading failed'));
                    };
                    
                    // Load image from data
                    if (imageData instanceof Uint8Array) {
                        const blob = new Blob([imageData], { type: 'image/png' });
                        img.src = URL.createObjectURL(blob);
                    } else {
                        img.src = imageData;
                    }
                });
            },
            
            createPlaceholder() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Create gradient brush tip
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(200,200,200,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                return canvas.toDataURL('image/png');
            }
        };

        // Brush parser - WITH REAL IMAGE PROCESSING
        const BrushParser = {
            async parse(files) {
                Logger.info('Parsing files for brushes...');
                const brushes = [];
                const usedNames = new Set();
                
                for (const file of files) {
                    try {
                        if (file.name.toLowerCase().endsWith('.png')) {
                            const brush = await this.createBrushFromPNG(file, usedNames);
                            if (brush) brushes.push(brush);
                        } else if (file.name.toLowerCase().endsWith('.abr')) {
                            const brush = await this.createBrushFromABR(file, usedNames);
                            if (brush) brushes.push(brush);
                        }
                    } catch (error) {
                        Logger.warning(`Failed to parse ${file.name}: ${error.message}`);
                    }
                }
                
                AppState.stats.brushesParsed = brushes.length;
                Logger.success(`Found ${brushes.length} brushes`);
                
                // Update preview
                UI.updatePreview(brushes);
                
                return brushes;
            },
            
            async createBrushFromPNG(file, usedNames) {
                try {
                    // Process the actual PNG image
                    const processedImage = await ImageProcessor.processImage(file.content);
                    const name = this.getUniqueName(file.name.replace('.png', ''), usedNames);
                    
                    return {
                        name: name,
                        brushSize: 50,
                        opacity: 80,
                        spacing: 25,
                        hardness: 50,
                        tipPNG: processedImage
                    };
                } catch (error) {
                    Logger.warning(`Failed to process PNG ${file.name}: ${error.message}`);
                    // Fallback to placeholder
                    return {
                        name: this.getUniqueName(file.name.replace('.png', ''), usedNames),
                        brushSize: 50,
                        opacity: 80,
                        spacing: 25,
                        hardness: 50,
                        tipPNG: ImageProcessor.createPlaceholder()
                    };
                }
            },
            
            async createBrushFromABR(file, usedNames) {
                try {
                    // Try to extract PNG from ABR
                    const data = file.content;
                    let pngStart = -1;
                    
                    // Find PNG signature
                    for (let i = 0; i < data.length - 8; i++) {
                        if (data[i] === 0x89 && data[i+1] === 0x50 && data[i+2] === 0x4E && data[i+3] === 0x47) {
                            pngStart = i;
                            break;
                        }
                    }
                    
                    if (pngStart !== -1) {
                        // Find PNG end
                        let pngEnd = pngStart;
                        while (pngEnd < data.length - 8) {
                            if (data[pngEnd] === 0x49 && data[pngEnd+1] === 0x45 && data[pngEnd+2] === 0x4E && data[pngEnd+3] === 0x44) {
                                pngEnd += 8;
                                break;
                            }
                            pngEnd++;
                        }
                        
                        const pngData = data.slice(pngStart, pngEnd);
                        const processedImage = await ImageProcessor.processImage(pngData);
                        const name = this.getUniqueName(file.name.replace('.abr', ''), usedNames);
                        
                        return {
                            name: name,
                            brushSize: 50,
                            opacity: 80,
                            spacing: 25,
                            hardness: 50,
                            tipPNG: processedImage
                        };
                    } else {
                        Logger.warning(`No PNG data found in ABR file: ${file.name}`);
                        return null;
                    }
                } catch (error) {
                    Logger.warning(`Failed to process ABR ${file.name}: ${error.message}`);
                    return null;
                }
            },
            
            getUniqueName(baseName, usedNames) {
                let name = UI.sanitizeName(baseName);
                let suffix = 1;
                let finalName = name;
                
                while (usedNames.has(finalName)) {
                    finalName = `${name}_${suffix}`;
                    suffix++;
                }
                
                usedNames.add(finalName);
                return finalName;
            }
        };

        // SUT Converter - WORKING DATABASE STRUCTURE
        const SUTConverter = {
            async createSUT(brush) {
                if (!SQL_READY) {
                    throw new Error('SQL engine not ready');
                }
                
                const db = new SQL.Database();
                
                try {
                    // Create proper CSP database structure
                    db.run(`
                        CREATE TABLE ToolCommon (
                            _PW_ID INTEGER PRIMARY KEY,
                            ToolType INTEGER DEFAULT 2,
                            Version INTEGER DEFAULT 1,
                            Name TEXT,
                            ToolUuid BLOB
                        )
                    `);
                    
                    db.run(`
                        CREATE TABLE BrushTip (
                            _PW_ID INTEGER PRIMARY KEY,
                            BrushTipUuid BLOB,
                            ImageData BLOB,
                            Width INTEGER DEFAULT 512,
                            Height INTEGER DEFAULT 512
                        )
                    `);
                    
                    db.run(`
                        CREATE TABLE BrushSetting (
                            _PW_ID INTEGER PRIMARY KEY,
                            BrushUuid BLOB,
                            Size REAL DEFAULT 50,
                            Opacity REAL DEFAULT 80,
                            Spacing REAL DEFAULT 25,
                            Hardness REAL DEFAULT 50
                        )
                    `);
                    
                    // Generate UUIDs
                    const toolUuid = this.generateUuidBlob();
                    const tipUuid = this.generateUuidBlob();
                    const brushUuid = this.generateUuid();
                    
                    // Insert tool data
                    db.run(
                        "INSERT INTO ToolCommon (_PW_ID, ToolType, Version, Name, ToolUuid) VALUES (1, 2, 1, ?, ?)",
                        [brush.name, toolUuid]
                    );
                    
                    // Get brush tip image data
                    let imageData;
                    try {
                        const response = await fetch(brush.tipPNG);
                        const arrayBuffer = await response.arrayBuffer();
                        imageData = new Uint8Array(arrayBuffer);
                    } catch (error) {
                        Logger.warning(`Failed to fetch image for ${brush.name}, using placeholder`);
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, 512, 512);
                        const blob = await new Promise(resolve => canvas.toBlob(resolve));
                        imageData = new Uint8Array(await blob.arrayBuffer());
                    }
                    
                    // Insert brush tip
                    db.run(
                        "INSERT INTO BrushTip (_PW_ID, BrushTipUuid, ImageData, Width, Height) VALUES (1, ?, ?, ?, ?)",
                        [tipUuid, imageData, 512, 512]
                    );
                    
                    // Insert brush settings
                    db.run(
                        "INSERT INTO BrushSetting (_PW_ID, BrushUuid, Size, Opacity, Spacing, Hardness) VALUES (1, ?, ?, ?, ?, ?)",
                        [brushUuid, brush.brushSize, brush.opacity, brush.spacing, brush.hardness]
                    );
                    
                    // Export and return
                    const dbBuffer = db.export();
                    return new Blob([dbBuffer], { type: 'application/octet-stream' });
                    
                } catch (error) {
                    throw new Error(`SUT creation failed: ${error.message}`);
                } finally {
                    db.close();
                }
            },
            
            generateUuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            },
            
            generateUuidBlob() {
                const uuid = this.generateUuid().replace(/-/g, '');
                const bytes = new Uint8Array(16);
                for (let i = 0; i < 16; i++) {
                    bytes[i] = parseInt(uuid.substr(i * 2, 2), 16);
                }
                return bytes;
            }
        };

        // Main converter
        const Converter = {
            async convertAll() {
                if (AppState.converting) return;
                
                AppState.converting = true;
                UI.disableConvertButton();
                Logger.clear();
                
                try {
                    UI.showStatus('Parsing brushes...', 'info');
                    const brushes = await BrushParser.parse(AppState.files);
                    
                    if (brushes.length === 0) {
                        throw new Error('No valid brushes found. Please upload PNG or ABR files.');
                    }
                    
                    const format = UI.elements.targetFormat.value;
                    const packageName = UI.sanitizeName(
                        document.getElementById('packageName').value || 'Converted_Brushes'
                    );
                    
                    UI.showStatus(`Converting ${brushes.length} brushes...`, 'info');
                    UI.showProgress(0);
                    
                    const zip = new JSZip();
                    const compressionLevel = parseInt(document.getElementById('compressionLevel').value);
                    
                    for (let i = 0; i < brushes.length; i++) {
                        const brush = brushes[i];
                        const progress = ((i + 1) / brushes.length) * 100;
                        UI.showProgress(progress);
                        
                        try {
                            if (format === 'sut') {
                                const sutBlob = await SUTConverter.createSUT(brush);
                                zip.file(`${brush.name}.sut`, sutBlob);
                            } else {
                                const response = await fetch(brush.tipPNG);
                                const pngBlob = await response.blob();
                                zip.file(`${brush.name}.png`, pngBlob);
                            }
                            
                            AppState.stats.brushesConverted++;
                            UI.updateStats();
                        } catch (error) {
                            Logger.error(`Failed to convert ${brush.name}: ${error.message}`);
                        }
                        
                        // Yield to UI
                        if (i % 5 === 0) await new Promise(r => setTimeout(r, 10));
                    }
                    
                    if (AppState.stats.brushesConverted === 0) {
                        throw new Error('No brushes were successfully converted');
                    }
                    
                    UI.showProgress(95);
                    const resultBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: compressionLevel }
                    });
                    
                    // Download
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(resultBlob);
                    link.download = `${packageName}_${format}_${Date.now()}.zip`;
                    link.click();
                    
                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(link.href), 1000);
                    
                    UI.showProgress(100);
                    const fileSizeMB = (resultBlob.size / (1024 * 1024)).toFixed(2);
                    UI.showStatus(`Conversion complete! Downloaded ${fileSizeMB} MB`, 'success');
                    Logger.success(`Successfully converted ${AppState.stats.brushesConverted} brushes`);
                    
                } catch (error) {
                    Logger.error('Conversion failed: ' + error.message);
                    UI.showStatus('Conversion failed', 'error');
                } finally {
                    AppState.converting = false;
                    if (AppState.filesLoaded) {
                        UI.enableConvertButton();
                    }
                }
            }
        };

        // Initialize the application
        window.addEventListener('load', async () => {
            UI.init();
            Logger.info('CSP Brush Converter Pro - Initializing...');
            UI.showStatus('Initializing...', 'info');
            
            // Initialize SQL.js
            try {
                SQL = await initSqlJs({
                    locateFile: (file) => {
                        if (file === 'sql-wasm.wasm') {
                            return 'https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.wasm';
                        }
                        return `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`;
                    }
                });
                SQL_READY = true;
                Logger.success('SQL.js engine ready');
            } catch (error) {
                Logger.error('SQL.js failed to load: ' + error.message);
                UI.showStatus('PNG export only available', 'warning');
                
                // Disable SUT option
                const sutOption = UI.elements.targetFormat.querySelector('option[value="sut"]');
                if (sutOption) {
                    sutOption.disabled = true;
                    if (UI.elements.targetFormat.value === 'sut') {
                        UI.elements.targetFormat.value = 'png';
                    }
                }
            }
            
            Logger.info('CSP Brush Converter Pro - Ready!');
            UI.showStatus('Ready - upload brush files to begin', 'success');
        });
    </script>
</body>
</html>

