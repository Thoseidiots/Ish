
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP .sut Brush Converter - Professional Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
             background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#fff}
        .container{max-width:1400px;margin:0 auto;background:rgba(255,255,255,.95);
                   border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);overflow:hidden}
        .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:30px;text-align:center}
        .header h1{font-size:clamp(1.5em,4vw,2.5em);margin-bottom:10px;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,.2)}
        .header p{opacity:.9;font-size:1.1em}
        .content{padding:clamp(20px,4vw,40px);color:#333}
        #dropZone{border:3px dashed #667eea;border-radius:15px;padding:clamp(40px,8vw,60px) clamp(20px,4vw,30px);
                  text-align:center;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
                  transition:all .3s;cursor:pointer;margin-bottom:30px}
        #dropZone:hover{border-color:#764ba2;transform:translateY(-2px);box-shadow:0 10px 30px rgba(102,126,234,.3)}
        #dropZone.dragover{border-color:#00d4ff;background:linear-gradient(135deg,#e0f7fa 0%,#b2ebf2 100%);transform:scale(1.02)}
        #dropZone svg{width:clamp(48px,8vw,64px);height:clamp(48px,8vw,64px);margin-bottom:20px;opacity:.7}
        .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:20px;margin-bottom:30px}
        .control-group{background:#f8f9fa;padding:20px;border-radius:10px;border:1px solid #e9ecef}
        .control-group label{display:block;font-weight:600;margin-bottom:8px;color:#495057;font-size:0.9em}
        input[type=text],input[type=number],select{width:100%;padding:10px;border:2px solid #dee2e6;border-radius:8px;font-size:1em;transition:border-color .3s}
        input[type=text]:focus,input[type=number]:focus,select:focus{outline:none;border-color:#667eea}
        input[type=range]{width:100%;margin:10px 0}
        .range-value{display:inline-block;background:#667eea;color:#fff;padding:2px 8px;border-radius:4px;font-size:0.85em;margin-left:10px}
        .btn{padding:15px 40px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
             color:#fff;border:none;border-radius:10px;cursor:pointer;font-size:1.1em;font-weight:600;
             transition:all .3s;box-shadow:0 4px 15px rgba(102,126,234,.4);display:inline-flex;align-items:center;gap:10px;width:100%;justify-content:center}
        .btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 20px rgba(102,126,234,.6)}
        .btn:disabled{background:#adb5bd;cursor:not-allowed;box-shadow:none}
        .btn-secondary{background:linear-gradient(135deg,#6c757d 0%,#495057 100%);box-shadow:0 4px 15px rgba(108,117,125,.4)}
        .btn-secondary:hover:not(:disabled){box-shadow:0 6px 20px rgba(108,117,125,.6)}
        .btn-danger{background:linear-gradient(135deg,#dc3545 0%,#c82333 100%);box-shadow:0 4px 15px rgba(220,53,69,.4)}
        .btn-danger:hover:not(:disabled){box-shadow:0 6px 20px rgba(220,53,69,.6)}
        .btn-success{background:linear-gradient(135deg,#28a745 0%,#20c997 100%);box-shadow:0 4px 15px rgba(40,167,69,.4)}
        .btn-success:hover:not(:disabled){box-shadow:0 6px 20px rgba(40,167,69,.6)}
        .status-bar{background:#e9ecef;padding:15px;border-radius:8px;margin-bottom:20px;display:none;align-items:center;gap:10px}
        .status-bar.show{display:flex}
        .status-bar.success{background:#d4edda;color:#155724}
        .status-bar.error{background:#f8d7da;color:#721c24}
        .status-bar.info{background:#d1ecf1;color:#0c5460}
        #log{background:#1e1e1e;padding:20px;border-radius:10px;max-height:400px;overflow-y:auto;
             font-family:'Courier New',monospace;font-size:.9em;line-height:1.6}
        .log-entry{padding:5px 0;border-left:3px solid transparent;padding-left:10px;margin-bottom:5px}
        .log-entry.success{color:#4caf50;border-color:#4caf50}
        .log-entry.info{color:#2196f3;border-color:#2196f3}
        .log-entry.error{color:#f44336;border-color:#f44336}
        .log-entry.warning{color:#ff9800;border-color:#ff9800}
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:30px}
        .stat-card{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:20px;border-radius:10px;color:#fff;text-align:center}
        .stat-card .value{font-size:clamp(1.5em,3vw,2em);font-weight:bold;margin-bottom:5px}
        .stat-card .label{opacity:.9;font-size:.9em}
        .progress-bar{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:10px;display:none}
        .progress-bar.show{display:block}
        .progress-fill{height:100%;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);width:0%;transition:width .3s}
        .format-info{margin-top:10px;padding:10px;background:#e3f2fd;border-radius:5px;font-size:.9em;color:#1565c0}
        .import-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:15px}
        .preview-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:10px;margin-top:20px}
        .preview-item{text-align:center}
        .preview-item img{width:100%;height:100px;object-fit:contain;border:1px solid #dee2e6;border-radius:5px;background:#fff}
        .preview-item p{font-size:.8em;margin-top:5px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
        .pressure-curve-editor{margin-top:15px;padding:15px;background:#f8f9fa;border-radius:8px}
        .curve-canvas{width:100%;height:150px;border:1px solid #dee2e6;border-radius:5px;background:#fff;cursor:crosshair;margin-top:10px;touch-action:none}
        .checkbox-group{display:flex;align-items:center;margin:10px 0}
        .checkbox-group input[type=checkbox]{margin-right:10px;width:auto}
        .tabs{display:flex;border-bottom:2px solid #dee2e6;margin-bottom:20px;overflow-x:auto;flex-wrap:wrap}
        .tab{padding:10px 20px;cursor:pointer;background:none;border:none;border-bottom:2px solid transparent;color:#495057;font-weight:500;white-space:nowrap;flex:1 0 50%}
        .tab.active{border-bottom-color:#667eea;color:#667eea}
        .tab-content{display:none}
        .tab-content.active{display:block}
        .footer{text-align:center;padding:20px;margin-top:30px;color:rgba(255,255,255,.7);font-size:.9em}
        .advanced-settings{background:#fff3cd;padding:15px;border-radius:8px;margin-top:20px}
        .advanced-settings h4{margin-bottom:10px;color:#856404}
        .info-banner{background:#d1ecf1;border:1px solid #bee5eb;border-radius:8px;padding:15px;margin-bottom:20px;color:#0c5460}
        .template-selector{background:#e7f3ff;border:2px solid #667eea;border-radius:10px;padding:20px;margin-bottom:20px}
        .template-selector h3{color:#667eea;margin-bottom:15px}
        .template-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px}
        .template-option{background:#fff;padding:15px;border-radius:8px;border:1px solid #dee2e6;cursor:pointer;transition:all .3s}
        .template-option:hover{border-color:#667eea;box-shadow:0 4px 12px rgba(102,126,234,.2)}
        .template-option.selected{border-color:#667eea;background:#f8f9ff}
        .template-option h4{margin-bottom:5px;color:#495057}
        .template-option p{font-size:.85em;color:#6c757d;margin-bottom:10px}
        .loading-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;z-index:9999}
        .loading-overlay.show{display:flex}
        .loading-spinner{width:50px;height:50px;border:5px solid #f3f3f3;border-top:5px solid #667eea;border-radius:50%;animation:spin 1s linear infinite}
        .button-group{display:flex;gap:10px;margin-bottom:20px}
        .button-group .btn{flex:1}
        @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
        @media(max-width:768px){.controls{grid-template-columns:1fr}.import-options{grid-template-columns:1fr}.curve-canvas{width:100% !important;height:200px !important}.button-group{flex-direction:column}.template-options{grid-template-columns:1fr}}
        .failed-brushes{background:#f8d7da;border:1px solid #f5c6cb;border-radius:8px;padding:15px;margin-top:20px;color:#721c24}
        .failed-brushes h4{margin-bottom:10px}
        .failed-brushes ul{list-style-position:inside;margin:0}
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    <div class="container">
        <div class="header">
            <h1>CSP .sut Brush Converter</h1>
            <p>Professional Edition - Convert your brushes to Clip Studio Paint format</p>
        </div>
        <div class="content">
            <div id="dropZone">
                <svg fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H5a5 5 0 0 1-1-9.9V7a3 3 0 0 1 4.52-2.59A4.98 4.98 0 0 1 17 8c0 .38-.04.74-.12 1.1zM11 11h3l-4-4-4 4h3v3h2v-3z"/></svg>
                <h2 style="color:#667eea;margin-bottom:10px">Drop Brush Files Here</h2>
                <p style="color:#6c757d;margin-bottom:20px">Supports: PNG, JPG, ABR, ZIP, .brushset files</p>
                <div class="import-options">
                    <button class="btn" id="importFilesBtn">Import Brush Files</button>
                    <button class="btn" id="importZipBtn">Import ZIP/Brushset</button>
                    <button class="btn btn-secondary" id="clearAllBtn">Clear All</button>
                </div>
                <input type="file" id="fileInput" multiple accept=".png,.jpg,.jpeg,.abr,.zip,.brushset" style="display:none">
                <input type="file" id="zipInput" accept=".zip,.brushset" style="display:none">
            </div>
            
            <div class="info-banner" id="infoBanner" style="display:none">
                <strong>‚ÑπÔ∏è Info:</strong> <span id="infoText"></span>
            </div>
            
            <div class="template-selector" id="templateSelector" style="display:none">
                <h3>üìã Select SUT Template (Required for .sut format)</h3>
                <p style="color:#6c757d;margin-bottom:15px">A template provides the database structure needed to create SUT files. Choose one of the options below:</p>
                <div class="template-options">
                    <div class="template-option" id="useDefaultTemplate">
                        <h4>üé® Use Default Template</h4>
                        <p>Recommended for most brushes. Creates standard CSP brushes with basic settings.</p>
                        <button class="btn btn-success" style="width:100%;margin-top:10px">Use Default</button>
                    </div>
                    <div class="template-option" id="useCustomTemplate">
                        <h4>üìÅ Load Custom Template</h4>
                        <p>Use your own .sut file as a template for specific brush types or custom settings.</p>
                        <button class="btn btn-secondary" style="width:100%;margin-top:10px">Load Template</button>
                    </div>
                </div>
                <input type="file" id="templateInput" accept=".sut" style="display:none">
            </div>
            
            <div class="stats" id="stats" style="display:none">
                <div class="stat-card"><div class="value" id="fileCount">0</div><div class="label">Files Loaded</div></div>
                <div class="stat-card"><div class="value" id="brushCount">0</div><div class="label">Brushes Found</div></div>
                <div class="stat-card"><div class="value" id="convertedCount">0</div><div class="label">Converted</div></div>
            </div>
            <div id="previewContainer" style="display:none;margin-bottom:20px;">
                <h3 style="margin-bottom:10px;color:#495057;">Brush Preview</h3>
                <div id="previewGrid" class="preview-grid"></div>
            </div>
            <!-- Tabs for different settings -->
            <div class="tabs">
                <button class="tab active" data-tab="basic">Basic Settings</button>
                <button class="tab" data-tab="advanced">Advanced</button>
                <button class="tab" data-tab="pressure">Pressure Curves</button>
            </div>
            <!-- Basic Settings Tab -->
            <div id="basic" class="tab-content active">
                <div class="controls">
                    <div class="control-group">
                        <label for="packageName">Package Name (max 100 chars)</label>
                        <input type="text" id="packageName" placeholder="My Custom Brushes" value="Converted Brushes" maxlength="100">
                    </div>
                    <div class="control-group">
                        <label for="authorName">Author Name</label>
                        <input type="text" id="authorName" placeholder="Artist Name">
                    </div>
                    <div class="control-group">
                        <label for="compressionLevel">Compression</label>
                        <select id="compressionLevel">
                            <option value="1">Fast</option>
                            <option value="6" selected>Balanced</option>
                            <option value="9">Maximum</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="outputFormat">Output Format</label>
                        <select id="outputFormat">
                            <option value="sut">Clip Studio Paint (.sut)</option>
                            <option value="png">Brush Tip PNGs Only</option>
                        </select>
                        <div class="format-info" id="formatInfo"></div>
                    </div>
                </div>
            </div>
            <!-- Advanced Settings Tab -->
            <div id="advanced" class="tab-content">
                <div class="controls">
                    <div class="control-group">
                        <label for="brushSize">Brush Size <span class="range-value" id="brushSizeValue">50</span></label>
                        <input type="range" id="brushSize" min="1" max="100" value="50">
                    </div>
                    <div class="control-group">
                        <label for="opacity">Opacity <span class="range-value" id="opacityValue">80</span></label>
                        <input type="range" id="opacity" min="1" max="100" value="80">
                    </div>
                    <div class="control-group">
                        <label for="spacing">Spacing <span class="range-value" id="spacingValue">10</span></label>
                        <input type="range" id="spacing" min="1" max="100" value="10">
                    </div>
                    <div class="control-group">
                        <label for="hardness">Hardness <span class="range-value" id="hardnessValue">50</span></label>
                        <input type="range" id="hardness" min="1" max="100" value="50">
                    </div>
                    <div class="control-group">
                        <label for="angle">Angle <span class="range-value" id="angleValue">0</span>¬∞</label>
                        <input type="range" id="angle" min="0" max="360" value="0">
                    </div>
                    <div class="control-group">
                        <label for="density">Density <span class="range-value" id="densityValue">100</span></label>
                        <input type="range" id="density" min="1" max="100" value="100">
                    </div>
                    <div class="control-group">
                        <label for="wetMix">Wet Mix <span class="range-value" id="wetMixValue">0.0</span></label>
                        <input type="range" id="wetMix" min="0" max="100" value="0" step="1">
                    </div>
                    <div class="control-group">
                        <div class="checkbox-group">
                            <input type="checkbox" id="textureMode">
                            <label for="textureMode">Texture Mode</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="sizePressure" checked>
                            <label for="sizePressure">Size Pressure</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="opacityPressure" checked>
                            <label for="opacityPressure">Opacity Pressure</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="densityPressure">
                            <label for="densityPressure">Density Pressure</label>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Pressure Curves Tab -->
            <div id="pressure" class="tab-content">
                <div class="pressure-curve-editor">
                    <h4>Size Pressure Curve</h4>
                    <canvas id="sizeCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
                    <button class="btn btn-secondary" id="resetSizeCurve" style="margin-top:10px;width:auto">Reset Curve</button>
                </div>
                <div class="pressure-curve-editor">
                    <h4>Opacity Pressure Curve</h4>
                    <canvas id="opacityCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
                    <button class="btn btn-secondary" id="resetOpacityCurve" style="margin-top:10px;width:auto">Reset Curve</button>
                </div>
                <div class="pressure-curve-editor">
                    <h4>Density Pressure Curve</h4>
                    <canvas id="densityCurveCanvas" class="curve-canvas" width="400" height="150"></canvas>
                    <button class="btn btn-secondary" id="resetDensityCurve" style="margin-top:10px;width:auto">Reset Curve</button>
                </div>
            </div>
            <div class="button-group">
                <button id="convertBtn" class="btn" disabled>Convert & Download</button>
                <button id="cancelBtn" class="btn btn-secondary" disabled>Cancel</button>
            </div>
            <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
            <div id="statusBar" class="status-bar"><span id="statusText">Ready</span></div>
            <div id="failedBrushesContainer" class="failed-brushes" style="display:none">
                <h4>Failed Conversions:</h4>
                <ul id="failedBrushesList"></ul>
            </div>
            <div id="log"></div>
        </div>
        <div class="footer">
            <p>CSP .sut Brush Converter - Professional Edition | Full CSP Database Schema Support</p>
            <p>Keyboard Shortcuts: Ctrl+Enter to convert | Esc to cancel</p>
        </div>
    </div>

    <script>
        // Global variables
        let SQL, SQL_READY = false;
        let SUT_TEMPLATE = null;
        
        // Initialize app when document is loaded
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize UI
            UI.init();
            Logger.info('Initializing CSP Brush Converter Professional Edition');
            
            // Show loading overlay
            UI.showLoading(true);
            
            // Initialize SQL.js with retry mechanism
            let retryCount = 0;
            const maxRetries = 3;
            
            while (retryCount < maxRetries && !SQL_READY) {
                try {
                    Logger.info('Loading SQL.js engine...');
                    SQL = await initSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
                    });
                    SQL_READY = true;
                    Logger.success('SQL.js engine initialized successfully');
                    break;
                } catch (error) {
                    retryCount++;
                    Logger.error(`Failed to initialize SQL.js (attempt ${retryCount}/${maxRetries}): ${error.message}`);
                    if (retryCount < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    } else {
                        UI.showInfo('SQL.js initialization failed - SUT conversion disabled. Please check your internet connection and refresh the page.');
                        UI.showStatus('SQL.js initialization failed - SUT conversion disabled', 'error');
                    }
                }
            }
            
            // Initialize pressure curves
            PressureCurveUtils.initCurveEditors();
            
            // Hide loading overlay
            UI.showLoading(false);
            
            // Enable convert button if both files and template are already loaded
            if (AppState.filesLoaded && AppState.templateLoaded) {
                UI.enableConvertButton();
            }
        });

        // Application state
        const AppState = {
            files: [],
            brushes: [],
            filesLoaded: false,
            converting: false,
            templateLoaded: false,
            abortController: null,
            stats: {
                filesLoaded: 0,
                brushesParsed: 0,
                brushesConverted: 0
            },
            maxFileSize: 50 * 1024 * 1024, // 50MB limit
            maxFiles: 100 // Maximum number of files
        };
        
        // UI management
        const UI = {
            elements: {
                dropZone: document.getElementById('dropZone'),
                fileInput: document.getElementById('fileInput'),
                zipInput: document.getElementById('zipInput'),
                templateInput: document.getElementById('templateInput'),
                importFilesBtn: document.getElementById('importFilesBtn'),
                importZipBtn: document.getElementById('importZipBtn'),
                clearAllBtn: document.getElementById('clearAllBtn'),
                useDefaultTemplate: document.getElementById('useDefaultTemplate'),
                useCustomTemplate: document.getElementById('useCustomTemplate'),
                templateSelector: document.getElementById('templateSelector'),
                convertBtn: document.getElementById('convertBtn'),
                cancelBtn: document.getElementById('cancelBtn'),
                log: document.getElementById('log'),
                statusBar: document.getElementById('statusBar'),
                statusText: document.getElementById('statusText'),
                progressBar: document.getElementById('progressBar'),
                progressFill: document.getElementById('progressFill'),
                stats: document.getElementById('stats'),
                fileCount: document.getElementById('fileCount'),
                brushCount: document.getElementById('brushCount'),
                convertedCount: document.getElementById('convertedCount'),
                outputFormat: document.getElementById('outputFormat'),
                formatInfo: document.getElementById('formatInfo'),
                previewContainer: document.getElementById('previewContainer'),
                previewGrid: document.getElementById('previewGrid'),
                infoBanner: document.getElementById('infoBanner'),
                infoText: document.getElementById('infoText'),
                loadingOverlay: document.getElementById('loadingOverlay'),
                failedBrushesContainer: document.getElementById('failedBrushesContainer'),
                failedBrushesList: document.getElementById('failedBrushesList')
            },
            init() {
                // Tab switching
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        tab.classList.add('active');
                        document.getElementById(tab.dataset.tab).classList.add('active');
                    });
                });
                
                // Range value updates
                const ranges = [
                    { id: 'brushSize', valueId: 'brushSizeValue', suffix: '' },
                    { id: 'opacity', valueId: 'opacityValue', suffix: '' },
                    { id: 'spacing', valueId: 'spacingValue', suffix: '' },
                    { id: 'hardness', valueId: 'hardnessValue', suffix: '' },
                    { id: 'angle', valueId: 'angleValue', suffix: '¬∞' },
                    { id: 'density', valueId: 'densityValue', suffix: '' },
                    { id: 'wetMix', valueId: 'wetMixValue', suffix: '', scale: 0.01 }
                ];
                
                ranges.forEach(range => {
                    const input = document.getElementById(range.id);
                    const value = document.getElementById(range.valueId);
                    input.addEventListener('input', () => {
                        const val = range.scale ? (input.value * range.scale).toFixed(1) : input.value;
                        value.textContent = val + range.suffix;
                    });
                    // Initial value display
                    const val = range.scale ? (input.value * range.scale).toFixed(1) : input.value;
                    value.textContent = val + range.suffix;
                });
                
                // Format info update
                this.elements.outputFormat.addEventListener('change', () => {
                    const format = this.elements.outputFormat.value;
                    const info = {
                        'sut': 'Full CSP brush files with metadata and pressure curves',
                        'png': 'Brush tip images only (no template needed)'
                    };
                    this.elements.formatInfo.textContent = info[format] || '';
                    
                    // Show/hide template selector based on format
                    if (format === 'sut' && AppState.filesLoaded && !AppState.templateLoaded) {
                        this.elements.templateSelector.style.display = 'block';
                        this.showInfo('SUT format requires a template. Choose default or load a custom template below.');
                    } else if (format === 'png') {
                        this.elements.templateSelector.style.display = 'none';
                        this.hideInfo();
                        if (AppState.filesLoaded) {
                            this.enableConvertButton();
                        }
                    }
                });
                
                // Setup event listeners
                this.elements.importFilesBtn.addEventListener('click', () => {
                    this.elements.fileInput.click();
                });
                
                this.elements.importZipBtn.addEventListener('click', () => {
                    this.elements.zipInput.click();
                });
                
                this.elements.clearAllBtn.addEventListener('click', () => {
                    this.clearAll();
                });
                
                // Template options
                this.elements.useDefaultTemplate.addEventListener('click', () => {
                    TemplateManager.loadDefaultTemplate();
                });
                
                this.elements.useCustomTemplate.addEventListener('click', () => {
                    this.elements.templateInput.click();
                });
                
                this.elements.fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        FileManager.handleFiles(Array.from(e.target.files));
                    }
                });
                
                this.elements.zipInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        FileManager.handleFiles(Array.from(e.target.files));
                    }
                });
                
                this.elements.templateInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        TemplateManager.loadTemplate(e.target.files[0]);
                    }
                });
                
                // Drag and drop
                this.elements.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.elements.dropZone.classList.add('dragover');
                });
                
                this.elements.dropZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.elements.dropZone.classList.remove('dragover');
                });
                
                this.elements.dropZone.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.elements.dropZone.classList.remove('dragover');
                    
                    if (e.dataTransfer.files.length > 0) {
                        const files = Array.from(e.dataTransfer.files);
                        await FileManager.handleFiles(files);
                    }
                });
                
                // Convert button
                this.elements.convertBtn.addEventListener('click', () => {
                    Converter.convertAll();
                });
                
                // Cancel button
                this.elements.cancelBtn.addEventListener('click', () => {
                    if (AppState.converting && AppState.abortController) {
                        AppState.abortController.abort();
                        this.showStatus('Conversion cancelled by user', 'info');
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'Enter') {
                        e.preventDefault();
                        if (!this.elements.convertBtn.disabled) {
                            Converter.convertAll();
                        }
                    } else if (e.key === 'Escape' && AppState.converting) {
                        e.preventDefault();
                        if (AppState.abortController) {
                            AppState.abortController.abort();
                            this.showStatus('Conversion cancelled by user', 'info');
                        }
                    }
                });
                
                // Initialize format info
                this.elements.outputFormat.dispatchEvent(new Event('change'));
            },
            clearAll() {
                // Clean up memory
                BrushParser.cleanup();
                
                // Reset state
                AppState.files = [];
                AppState.brushes = [];
                AppState.filesLoaded = false;
                AppState.templateLoaded = false;
                AppState.stats = {
                    filesLoaded: 0,
                    brushesParsed: 0,
                    brushesConverted: 0
                };
                
                // Reset UI
                this.elements.stats.style.display = 'none';
                this.elements.previewContainer.style.display = 'none';
                this.elements.previewGrid.innerHTML = '';
                this.elements.failedBrushesContainer.style.display = 'none';
                this.elements.failedBrushesList.innerHTML = '';
                this.elements.templateSelector.style.display = 'none';
                this.hideInfo();
                this.disableConvertButton();
                this.elements.cancelBtn.disabled = true;
                
                // Clear file inputs
                this.elements.fileInput.value = '';
                this.elements.zipInput.value = '';
                this.elements.templateInput.value = '';
                
                Logger.clear();
                Logger.info('Application reset - ready for new files');
                this.showStatus('Ready - load brush files to begin', 'success');
            },
            showStatus(message, type = 'info') {
                this.elements.statusBar.className = `status-bar show ${type}`;
                this.elements.statusText.textContent = message;
            },
            showProgress(percent) {
                this.elements.progressBar.classList.add('show');
                this.elements.progressFill.style.width = percent + '%';
            },
            showInfo(message) {
                this.elements.infoBanner.style.display = 'block';
                this.elements.infoText.textContent = message;
            },
            hideInfo() {
                this.elements.infoBanner.style.display = 'none';
            },
            showLoading(show) {
                if (show) {
                    this.elements.loadingOverlay.classList.add('show');
                } else {
                    this.elements.loadingOverlay.classList.remove('show');
                }
            },
            updateStats() {
                this.elements.stats.style.display = 'grid';
                this.elements.fileCount.textContent = AppState.stats.filesLoaded;
                this.elements.brushCount.textContent = AppState.stats.brushesParsed;
                this.elements.convertedCount.textContent = AppState.stats.brushesConverted;
            },
            updatePreview(brushes) {
                this.elements.previewGrid.innerHTML = '';
                if (brushes.length === 0) {
                    this.elements.previewContainer.style.display = 'none';
                    return;
                }
                this.elements.previewContainer.style.display = 'block';
                brushes.slice(0, 12).forEach(brush => {
                    const item = document.createElement('div');
                    item.className = 'preview-item';
                    const img = document.createElement('img');
                    img.src = brush.tipPNG;
                    img.alt = brush.name;
                    img.loading = 'lazy';
                    const label = document.createElement('p');
                    label.textContent = brush.name;
                    label.title = brush.name;
                    item.appendChild(img);
                    item.appendChild(label);
                    this.elements.previewGrid.appendChild(item);
                });
                if (brushes.length > 12) {
                    const more = document.createElement('div');
                    more.className = 'preview-item';
                    more.innerHTML = `<p style="text-align:center;padding-top:40px">+${brushes.length - 12} more</p>`;
                    this.elements.previewGrid.appendChild(more);
                }
            },
            showFailedBrushes(failedBrushes) {
                if (failedBrushes.length === 0) {
                    this.elements.failedBrushesContainer.style.display = 'none';
                    return;
                }
                this.elements.failedBrushesContainer.style.display = 'block';
                this.elements.failedBrushesList.innerHTML = failedBrushes
                    .map(b => `<li>${b.name}: ${b.error}</li>`)
                    .join('');
            },
            enableConvertButton() {
                const format = this.elements.outputFormat.value;
                if (format === 'png' || (format === 'sut' && AppState.templateLoaded)) {
                    this.elements.convertBtn.disabled = false;
                }
            },
            disableConvertButton() {
                this.elements.convertBtn.disabled = true;
            },
            sanitizeName(name) {
                return name.replace(/[<>:"/\\|?*]/g, '_')
                          .replace(/\s+/g, ' ')
                          .substring(0, 100)
                          .trim() || 'Brush';
            }
        };
        
        // Logging system
        const Logger = {
            log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                UI.elements.log.appendChild(entry);
                UI.elements.log.scrollTop = UI.elements.log.scrollHeight;
            },
            info(message) { this.log(message, 'info'); },
            success(message) { this.log(message, 'success'); },
            error(message) { this.log(message, 'error'); },
            warning(message) { this.log(message, 'warning'); },
            clear() {
                UI.elements.log.innerHTML = '';
            }
        };
        
        // UUID utilities
        const UUIDUtils = {
            generateUuid() {
                return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
            },
            uuidToBlob(uuidStr) {
                const cleanUuid = uuidStr.replace(/-/g, '');
                const bytes = new Uint8Array(16);
                for (let i = 0; i < 16; i++) {
                    bytes[i] = parseInt(cleanUuid.substr(i * 2, 2), 16);
                }
                return bytes;
            },
            generateUuidBlob() {
                return this.uuidToBlob(this.generateUuid());
            }
        };
        
        // Pressure curve utilities
        const PressureCurveUtils = {
            curveData: {},
            createPressureCurve(points) {
                // Validate and clamp points
                const validatedPoints = [];
                for (const [x, y] of points) {
                    const xClamped = Math.max(0.0, Math.min(1.0, x));
                    const yClamped = Math.max(0.0, Math.min(1.0, y));
                    validatedPoints.push([xClamped, yClamped]);
                }
                // Sort by x
                validatedPoints.sort((a, b) => a[0] - b[0]);
                // CSP requires at least 2 points
                if (validatedPoints.length < 2) {
                    validatedPoints.push([0.0, 0.0], [1.0, 1.0]);
                }
                // Create binary data (big-endian)
                const data = new DataView(new ArrayBuffer(2 + validatedPoints.length * 4));
                data.setUint16(0, validatedPoints.length, false); // count
                let offset = 2;
                for (const [x, y] of validatedPoints) {
                    data.setUint16(offset, Math.round(x * 65535), false); // x
                    data.setUint16(offset + 2, Math.round(y * 65535), false); // y
                    offset += 4;
                }
                return new Uint8Array(data.buffer);
            },
            initCurveEditors() {
                const curves = {
                    size: { canvas: document.getElementById('sizeCurveCanvas'), points: [[0,0], [0.3,0.2], [0.7,0.8], [1,1]] },
                    opacity: { canvas: document.getElementById('opacityCurveCanvas'), points: [[0,0], [0.5,0.3], [1,1]] },
                    density: { canvas: document.getElementById('densityCurveCanvas'), points: [[0,0], [1,1]] }
                };
                
                Object.keys(curves).forEach(type => {
                    const curve = curves[type];
                    this.setupCurveEditor(curve.canvas, curve.points, type);
                    // Reset button
                    document.getElementById(`reset${type.charAt(0).toUpperCase() + type.slice(1)}Curve`)
                        .addEventListener('click', () => {
                            curve.points = type === 'size' ? [[0,0], [0.3,0.2], [0.7,0.8], [1,1]] :
                                           type === 'opacity' ? [[0,0], [0.5,0.3], [1,1]] :
                                           [[0,0], [1,1]];
                            this.drawCurve(curve.canvas, curve.points);
                        });
                });
                this.curveData = curves;
            },
            setupCurveEditor(canvas, points, type) {
                const ctx = canvas.getContext('2d');
                let isDragging = false;
                let dragIndex = -1;
                
                const draw = () => this.drawCurve(canvas, points);
                
                const getEventPos = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    return {
                        x: (clientX - rect.left) / rect.width,
                        y: 1 - (clientY - rect.top) / rect.height
                    };
                };
                
                const getPointIndex = (pos) => {
                    for (let i = 0; i < points.length; i++) {
                        const dx = pos.x - points[i][0];
                        const dy = pos.y - points[i][1];
                        if (Math.sqrt(dx*dx + dy*dy) < 0.05) {
                            return i;
                        }
                    }
                    return -1;
                };
                
                // Mouse events
                canvas.addEventListener('mousedown', (e) => {
                    const pos = getEventPos(e);
                    dragIndex = getPointIndex(pos);
                    if (dragIndex !== -1) {
                        isDragging = true;
                        canvas.style.cursor = 'grabbing';
                    }
                    e.preventDefault();
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    const pos = getEventPos(e);
                    if (isDragging && dragIndex !== -1) {
                        if (dragIndex === 0) {
                            points[dragIndex] = [0, Math.max(0, Math.min(1, pos.y))];
                        } else if (dragIndex === points.length - 1) {
                            points[dragIndex] = [1, Math.max(0, Math.min(1, pos.y))];
                        } else {
                            points[dragIndex] = [
                                Math.max(points[dragIndex-1][0] + 0.01, Math.min(points[dragIndex+1][0] - 0.01, pos.x)),
                                Math.max(0, Math.min(1, pos.y))
                            ];
                        }
                        draw();
                    } else {
                        canvas.style.cursor = getPointIndex(pos) !== -1 ? 'grab' : 'crosshair';
                    }
                    e.preventDefault();
                });
                
                canvas.addEventListener('mouseup', (e) => {
                    isDragging = false;
                    dragIndex = -1;
                    canvas.style.cursor = 'crosshair';
                    e.preventDefault();
                });
                
                canvas.addEventListener('mouseleave', (e) => {
                    isDragging = false;
                    dragIndex = -1;
                    canvas.style.cursor = 'crosshair';
                    e.preventDefault();
                });
                
                // Touch events for mobile
                canvas.addEventListener('touchstart', (e) => {
                    const pos = getEventPos(e);
                    dragIndex = getPointIndex(pos);
                    if (dragIndex !== -1) {
                        isDragging = true;
                    }
                    e.preventDefault();
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (isDragging && dragIndex !== -1) {
                        const pos = getEventPos(e);
                        if (dragIndex === 0) {
                            points[dragIndex] = [0, Math.max(0, Math.min(1, pos.y))];
                        } else if (dragIndex === points.length - 1) {
                            points[dragIndex] = [1, Math.max(0, Math.min(1, pos.y))];
                        } else {
                            points[dragIndex] = [
                                Math.max(points[dragIndex-1][0] + 0.01, Math.min(points[dragIndex+1][0] - 0.01, pos.x)),
                                Math.max(0, Math.min(1, pos.y))
                            ];
                        }
                        draw();
                    }
                    e.preventDefault();
                });
                
                canvas.addEventListener('touchend', (e) => {
                    isDragging = false;
                    dragIndex = -1;
                    e.preventDefault();
                });
                
                draw();
            },
            drawCurve(canvas, points) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = (width / 10) * i;
                    const y = (height / 10) * i;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Draw axes labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText('0', 5, height - 5);
                ctx.fillText('1', width - 12, height - 5);
                ctx.fillText('0', 5, height - 5);
                ctx.fillText('1', 5, 15);
                
                // Draw curve
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                points.forEach((point, i) => {
                    const x = point[0] * width;
                    const y = (1 - point[1]) * height;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw points
                points.forEach(point => {
                    const x = point[0] * width;
                    const y = (1 - point[1]) * height;
                    ctx.fillStyle = '#667eea';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            },
            getCurveData(type) {
                if (this.curveData && this.curveData[type]) {
                    return this.createPressureCurve(this.curveData[type].points);
                }
                
                // Return defaults based on type
                if (type === 'size') {
                    return this.createPressureCurve([[0,0], [0.3,0.2], [0.7,0.8], [1,1]]);
                } else if (type === 'opacity') {
                    return this.createPressureCurve([[0,0], [0.5,0.3], [1,1]]);
                } else {
                    return this.createPressureCurve([[0,0], [1,1]]);
                }
            }
        };
        
        // Template manager with default template
        const TemplateManager = {
            templateCache: new Map(),
            async loadDefaultTemplate() {
                try {
                    UI.showLoading(true);
                    UI.showStatus('Loading default SUT template...', 'info');
                    Logger.info('Loading default SUT template');
                    
                    // Create a minimal valid SUT template
                    const templateData = await this.createDefaultSUTTemplate();
                    
                    SUT_TEMPLATE = templateData;
                    AppState.templateLoaded = true;
                    
                    UI.elements.templateSelector.style.display = 'none';
                    UI.hideInfo();
                    
                    Logger.success('Default SUT template loaded successfully');
                    UI.showStatus('Default template loaded - ready to convert', 'success');
                    
                    if (AppState.filesLoaded && AppState.files.length > 0) {
                        UI.enableConvertButton();
                    }
                    
                    UI.showLoading(false);
                    return true;
                } catch (error) {
                    Logger.error(`Failed to load default template: ${error.message}`);
                    UI.showStatus('Error loading default template', 'error');
                    UI.showLoading(false);
                    return false;
                }
            },
            async createDefaultSUTTemplate() {
                // Create a minimal but valid CSP SUT database
                const db = new SQL.Database();
                
                // Create required tables
                db.run(`CREATE TABLE Manager (
                    _PW_ID INTEGER PRIMARY KEY,
                    CurrentNodeUuid BLOB,
                    SavedCount INTEGER DEFAULT 1
                )`);
                
                db.run(`CREATE TABLE Node (
                    _PW_ID INTEGER PRIMARY KEY,
                    NodeName TEXT,
                    NodeMaterialUuid BLOB,
                    NodeVariantID TEXT
                )`);
                
                db.run(`CREATE TABLE MaterialFile (
                    _PW_ID INTEGER PRIMARY KEY,
                    MaterialUuid BLOB,
                    FileData BLOB
                )`);
                
                db.run(`CREATE TABLE Variant (
                    _PW_ID INTEGER PRIMARY KEY,
                    VariantID TEXT,
                    VariantData BLOB
                )`);
                
                // Insert default manager record
                db.run("INSERT INTO Manager (_PW_ID, CurrentNodeUuid, SavedCount) VALUES (1, ?, 1)", 
                       [UUIDUtils.generateUuidBlob()]);
                
                // Create default node and material
                const nodeUuid = UUIDUtils.generateUuidBlob();
                const materialUuid = UUIDUtils.generateUuidBlob();
                
                db.run("INSERT INTO Node (_PW_ID, NodeName, NodeMaterialUuid, NodeVariantID) VALUES (1, 'Default Brush', ?, ?)",
                       [materialUuid, UUIDUtils.generateUuid().replace(/-/g, '')]);
                
                db.run("INSERT INTO MaterialFile (_PW_ID, MaterialUuid, FileData) VALUES (1, ?, ?)",
                       [materialUuid, new Uint8Array([0])]); // Empty placeholder
                
                // Create default variant
                db.run("INSERT INTO Variant (_PW_ID, VariantID, VariantData) VALUES (1, ?, ?)",
                       [UUIDUtils.generateUuid().replace(/-/g, ''), new Uint8Array([0])]);
                
                return db.export();
            },
            async loadTemplate(file) {
                try {
                    UI.showLoading(true);
                    UI.showStatus(`Loading template: ${file.name}`, 'info');
                    Logger.info(`Loading SUT template: ${file.name}`);
                    
                    // Check cache first
                    const cacheKey = `${file.name}-${file.size}-${file.lastModified}`;
                    if (this.templateCache.has(cacheKey)) {
                        SUT_TEMPLATE = this.templateCache.get(cacheKey);
                        AppState.templateLoaded = true;
                        Logger.info('Using cached template');
                        UI.showStatus('Template loaded from cache - ready for conversion', 'success');
                        
                        UI.elements.templateSelector.style.display = 'none';
                        UI.hideInfo();
                        
                        if (AppState.filesLoaded && AppState.files.length > 0) {
                            UI.enableConvertButton();
                        }
                        
                        UI.showLoading(false);
                        return true;
                    }
                    
                    const arrayBuffer = await file.arrayBuffer();
                    const db = new SQL.Database(new Uint8Array(arrayBuffer));
                    // Validate template
                    if (!this.validateTemplate(db)) {
                        Logger.error('Invalid SUT template - missing required tables');
                        UI.showStatus('Invalid template file - must be a valid CSP brush', 'error');
                        UI.showLoading(false);
                        return false;
                    }
                    
                    SUT_TEMPLATE = new Uint8Array(arrayBuffer);
                    AppState.templateLoaded = true;
                    
                    // Cache the template
                    this.templateCache.set(cacheKey, SUT_TEMPLATE);
                    
                    UI.elements.templateSelector.style.display = 'none';
                    UI.hideInfo();
                    
                    Logger.success('SUT template loaded successfully');
                    UI.showStatus('Template loaded - ready for conversion', 'success');
                    
                    if (AppState.filesLoaded && AppState.files.length > 0) {
                        UI.enableConvertButton();
                    }
                    
                    db.close();
                    UI.showLoading(false);
                    return true;
                } catch (error) {
                    Logger.error(`Failed to load template: ${error.message}`);
                    UI.showStatus('Error loading template file', 'error');
                    UI.showLoading(false);
                    return false;
                }
            },
            validateTemplate(db) {
                const requiredTables = ['Manager', 'MaterialFile', 'Node'];
                const cursor = db.prepare("SELECT name FROM sqlite_master WHERE type='table'");
                const tables = [];
                while (cursor.step()) {
                    tables.push(cursor.get()[0]);
                }
                cursor.free();
                
                const missing = requiredTables.filter(t => !tables.includes(t));
                if (missing.length > 0) {
                    Logger.warning(`Template missing tables: ${missing.join(', ')}`);
                    return false;
                }
                return true;
            }
        };
        
        // File management
        const FileManager = {
            async handleFiles(files) {
                Logger.clear();
                UI.showStatus('Loading files...', 'info');
                UI.disableConvertButton();
                AppState.files = [];
                
                try {
                    // Check file count limit
                    if (files.length > AppState.maxFiles) {
                        UI.showInfo(`Too many files selected. Only the first ${AppState.maxFiles} files will be processed.`);
                        files = files.slice(0, AppState.maxFiles);
                    }
                    
                    for (const file of files) {
                        if (file.size === 0) {
                            Logger.warning(`Skipping empty file: ${file.name}`);
                            continue;
                        }
                        
                        if (file.size > AppState.maxFileSize) {
                            Logger.warning(`Skipping large file: ${file.name} (exceeds ${AppState.maxFileSize / 1024 / 1024}MB limit)`);
                            continue;
                        }
                        
                        const ext = file.name.toLowerCase().split('.').pop();
                        if (['zip', 'brushset'].includes(ext)) {
                            await this.extractZip(file);
                        } else {
                            await this.addFile(file);
                        }
                    }
                    
                    AppState.stats.filesLoaded = AppState.files.length;
                    AppState.filesLoaded = true;
                    UI.updateStats();
                    Logger.success(`Loaded ${AppState.files.length} files`);
                    
                    // Update status based on what's loaded
                    if (AppState.files.length === 0) {
                        UI.showStatus('No valid files loaded', 'error');
                        return;
                    }
                    
                    const format = UI.elements.outputFormat.value;
                    if (format === 'png') {
                        UI.enableConvertButton();
                        UI.showStatus('Ready to convert to PNG format', 'success');
                    } else if (format === 'sut') {
                        if (AppState.templateLoaded) {
                            UI.enableConvertButton();
                            UI.showStatus('Ready to convert', 'success');
                        } else {
                            UI.elements.templateSelector.style.display = 'block';
                            UI.showInfo('SUT format requires a template. Choose default or load a custom template below.');
                            UI.showStatus('Files loaded - select a template to continue', 'info');
                        }
                    }
                } catch (error) {
                    Logger.error('Failed to load files: ' + error.message);
                    UI.showStatus('Error loading files', 'error');
                }
            },
            async addFile(file) {
                try {
                    Logger.info(`Adding file: ${file.name}`);
                    const content = new Uint8Array(await file.arrayBuffer());
                    AppState.files.push({
                        name: file.name,
                        content: content
                    });
                } catch (error) {
                    Logger.warning(`Failed to read file: ${file.name} - ${error.message}`);
                    throw error;
                }
            },
            async extractZip(file) {
                try {
                    Logger.info(`Extracting ZIP file: ${file.name}`);
                    const zip = await JSZip.loadAsync(await file.arrayBuffer());
                    
                    const promises = [];
                    let pngCount = 0;
                    
                    zip.forEach((path, entry) => {
                        if (!entry.dir) {
                            const fileName = path.split('/').pop().toLowerCase();
                            if (fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg')) {
                                pngCount++;
                                promises.push(
                                    entry.async('uint8array').then(content => {
                                        AppState.files.push({
                                            name: path.split('/').pop(),
                                            content: content
                                        });
                                    }).catch(err => {
                                        Logger.warning(`Failed to extract ${path}: ${err.message}`);
                                    })
                                );
                            }
                        }
                    });
                    
                    await Promise.all(promises);
                    Logger.success(`Extracted ${pngCount} image files from ZIP`);
                } catch (error) {
                    Logger.error('ZIP extraction failed: ' + error.message);
                    throw error;
                }
            }
        };
        
        // Image processor with CORS handling
        const ImageProcessor = {
            async processImage(imageData) {
                return new Promise((resolve, reject) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        try {
                            // Resize to max 512x512 while maintaining aspect ratio
                            const maxSize = 512;
                            const scale = Math.min(maxSize / img.width, maxSize / img.height, 1);
                            canvas.width = img.width * scale;
                            canvas.height = img.height * scale;
                            
                            // Draw image
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            
                            // Check and handle alpha channel
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            let hasAlpha = false;
                            for (let i = 3; i < imageData.data.length; i += 4) {
                                if (imageData.data[i] < 255) {
                                    hasAlpha = true;
                                    break;
                                }
                            }
                            
                            // If no alpha, create one based on luminance
                            if (!hasAlpha) {
                                Logger.warning('Image missing alpha channel - generating from luminance');
                                for (let i = 0; i < imageData.data.length; i += 4) {
                                    const r = imageData.data[i];
                                    const g = imageData.data[i + 1];
                                    const b = imageData.data[i + 2];
                                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                                    // Keep original RGB but set alpha based on luminance
                                    imageData.data[i + 3] = 255 - Math.round(luminance * 0.8);
                                }
                                ctx.putImageData(imageData, 0, 0);
                            }
                            
                            // Convert to data URL
                            canvas.toBlob((blob) => {
                                if (blob) {
                                    const reader = new FileReader();
                                    reader.onload = () => resolve(reader.result);
                                    reader.onerror = () => reject(new Error('Failed to read blob'));
                                    reader.readAsDataURL(blob);
                                } else {
                                    reject(new Error('Canvas to blob failed'));
                                }
                            }, 'image/png', 0.9);
                        } catch (error) {
                            reject(error);
                        } finally {
                            URL.revokeObjectURL(img.src);
                        }
                    };
                    
                    img.onerror = (e) => {
                        reject(new Error('Image loading failed: ' + e.message));
                    };
                    
                    // Load image from data
                    if (imageData instanceof Uint8Array) {
                        const blob = new Blob([imageData], { type: 'image/png' });
                        img.src = URL.createObjectURL(blob);
                    } else {
                        img.src = imageData;
                    }
                });
            },
            createPlaceholder() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Create gradient brush tip
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(200,200,200,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                return canvas.toDataURL('image/png');
            }
        };
        
        // Brush parser with memory cleanup
        const BrushParser = {
            blobUrls: [],
            async parse(files) {
                Logger.info('Parsing files for brushes...');
                const brushes = [];
                const usedNames = new Set();
                
                // Cleanup previous blob URLs
                this.cleanup();
                
                for (const file of files) {
                    try {
                        const lowerName = file.name.toLowerCase();
                        
                        if (lowerName.endsWith('.png') || lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg')) {
                            const brush = await this.createBrushFromPNG(file, usedNames);
                            if (brush) brushes.push(brush);
                        } else if (lowerName.endsWith('.abr')) {
                            const brush = await this.createBrushFromABR(file, usedNames);
                            if (brush) brushes.push(brush);
                        }
                    } catch (error) {
                        Logger.warning(`Failed to parse ${file.name}: ${error.message}`);
                    }
                }
                
                AppState.stats.brushesParsed = brushes.length;
                Logger.success(`Found ${brushes.length} brushes`);
                // Update preview
                UI.updatePreview(brushes);
                return brushes;
            },
            async createBrushFromPNG(file, usedNames) {
                try {
                    const processedImage = await ImageProcessor.processImage(file.content);
                    if (processedImage.startsWith('blob:')) {
                        this.blobUrls.push(processedImage);
                    }
                    const name = this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames);
                    return {
                        name: name,
                        tipPNG: processedImage
                    };
                } catch (error) {
                    Logger.warning(`Failed to process image ${file.name}: ${error.message}`);
                    const placeholder = ImageProcessor.createPlaceholder();
                    this.blobUrls.push(placeholder);
                    return {
                        name: this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames),
                        tipPNG: placeholder
                    };
                }
            },
            async createBrushFromABR(file, usedNames) {
                try {
                    Logger.info(`Processing ABR file: ${file.name}`);
                    const data = file.content;
                    let pngStart = -1;
                    
                    // Find PNG signature
                    for (let i = 0; i < data.length - 8; i++) {
                        if (data[i] === 0x89 && data[i+1] === 0x50 && data[i+2] === 0x4E && data[i+3] === 0x47) {
                            pngStart = i;
                            break;
                        }
                    }
                    
                    if (pngStart !== -1) {
                        // Find PNG end
                        let pngEnd = pngStart;
                        while (pngEnd < data.length - 8) {
                            if (data[pngEnd] === 0x49 && data[pngEnd+1] === 0x45 && data[pngEnd+2] === 0x4E && data[pngEnd+3] === 0x44) {
                                pngEnd += 8;
                                break;
                            }
                            pngEnd++;
                        }
                        
                        const pngData = data.slice(pngStart, pngEnd);
                        const processedImage = await ImageProcessor.processImage(pngData);
                        if (processedImage.startsWith('blob:')) {
                            this.blobUrls.push(processedImage);
                        }
                        const name = this.getUniqueName(file.name.replace('.abr', ''), usedNames);
                        return {
                            name: name,
                            tipPNG: processedImage
                        };
                    } else {
                        Logger.warning(`No PNG data found in ABR file: ${file.name}`);
                        const placeholder = ImageProcessor.createPlaceholder();
                        this.blobUrls.push(placeholder);
                        return {
                            name: this.getUniqueName(file.name.replace('.abr', ''), usedNames),
                            tipPNG: placeholder
                        };
                    }
                } catch (error) {
                    Logger.warning(`Failed to process ABR ${file.name}: ${error.message}`);
                    const placeholder = ImageProcessor.createPlaceholder();
                    this.blobUrls.push(placeholder);
                    return {
                        name: this.getUniqueName(file.name.replace('.abr', ''), usedNames),
                        tipPNG: placeholder
                    };
                }
            },
            getUniqueName(baseName, usedNames) {
                let name = UI.sanitizeName(baseName);
                let suffix = 1;
                let finalName = name;
                while (usedNames.has(finalName)) {
                    finalName = `${name}_${suffix}`;
                    suffix++;
                }
                usedNames.add(finalName);
                return finalName;
            },
            cleanup() {
                // Revoke all blob URLs
                if (this.blobUrls) {
                    this.blobUrls.forEach(url => {
                        if (url && url.startsWith('blob:')) {
                            URL.revokeObjectURL(url);
                        }
                    });
                    this.blobUrls = [];
                }
                
                // Also cleanup brush images
                if (AppState.brushes) {
                    AppState.brushes.forEach(brush => {
                        if (brush.tipPNG && brush.tipPNG.startsWith('blob:')) {
                            URL.revokeObjectURL(brush.tipPNG);
                        }
                    });
                }
            }
        };
        
        // SUT Converter - Professional Edition with full CSP schema support
        const SUTConverter = {
            async createSUT(brush, params) {
                if (!SQL_READY || !SUT_TEMPLATE) {
                    throw new Error('SQL engine or template not ready. Please load a template first.');
                }
                
                const db = new SQL.Database(SUT_TEMPLATE);
                try {
                    // Get primary node info
                    const nodeInfo = this.getPrimaryNode(db);
                    if (!nodeInfo) {
                        throw new Error('Could not find primary node in template');
                    }
                    
                    // Update brush name with SQL injection protection
                    const sanitizedName = brush.name.replace(/[^a-zA-Z0-9\s\-_]/g, '');
                    db.run("UPDATE Node SET NodeName = ? WHERE _PW_ID = ?", [sanitizedName, nodeInfo.node_id]);
                    
                    // Get and update image data
                    let imageData;
                    try {
                        // For data URLs, extract the base64 part
                        if (brush.tipPNG.startsWith('image')) {
                            const base64Data = brush.tipPNG.split(',')[1];
                            imageData = new Uint8Array(atob(base64Data).split('').map(c => c.charCodeAt(0)));
                        } else {
                            // For blob URLs
                            const response = await fetch(brush.tipPNG, { signal: AppState.abortController?.signal });
                            imageData = new Uint8Array(await response.arrayBuffer());
                        }
                    } catch (error) {
                        Logger.warning(`Failed to fetch image for ${brush.name}, using placeholder`);
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(0, 0, 512, 512);
                        
                        const dataURL = canvas.toDataURL('image/png');
                        const base64Data = dataURL.split(',')[1];
                        imageData = new Uint8Array(atob(base64Data).split('').map(c => c.charCodeAt(0)));
                    }
                    
                    // Update MaterialFile
                    db.run("UPDATE MaterialFile SET FileData = ? WHERE _PW_ID = ?", [imageData, nodeInfo.material_id]);
                    
                    // Update brush parameters if Variant table exists
                    if (this.hasVariantTable(db)) {
                        this.updateBrushParameters(db, nodeInfo, params);
                    }
                    
                    // Update Manager metadata
                    if (this.hasManagerTable(db)) {
                        // Get current saved count or default to 1
                        let savedCount = 1;
                        const countCursor = db.prepare("SELECT SavedCount FROM Manager WHERE _PW_ID = 1 LIMIT 1");
                        if (countCursor.step()) {
                            savedCount = countCursor.get()[0] + 1;
                        }
                        countCursor.free();
                        
                        db.run("UPDATE Manager SET CurrentNodeUuid = ?, SavedCount = ? WHERE _PW_ID = 1", 
                               [UUIDUtils.generateUuidBlob(), savedCount]);
                    }
                    
                    // Export database
                    const dbBuffer = db.export();
                    return new Blob([dbBuffer], { type: 'application/octet-stream' });
                } catch (error) {
                    throw new Error(`SUT creation failed: ${error.message}`);
                } finally {
                    try {
                        db.close();
                    } catch (e) {
                        // Ignore close errors
                    }
                }
            },
            getPrimaryNode(db) {
                try {
                    // First try to find a node with material link
                    const cursor = db.prepare(`
                        SELECT n._PW_ID as node_id, n.NodeMaterialUuid as node_uuid, 
                               m._PW_ID as material_id, m.MaterialUuid as material_uuid
                        FROM Node n 
                        LEFT JOIN MaterialFile m ON n.NodeMaterialUuid = m.MaterialUuid 
                        WHERE n.NodeName IS NOT NULL AND n.NodeName != '' 
                        ORDER BY n._PW_ID ASC 
                        LIMIT 1
                    `);
                    
                    if (cursor.step()) {
                        const result = cursor.get();
                        cursor.free();
                        return {
                            node_id: result[0],
                            node_uuid: result[1],
                            material_id: result[2],
                            material_uuid: result[3]
                        };
                    }
                    cursor.free();
                } catch (e) {
                    Logger.warning('Error finding primary node with material link');
                }
                
                // Fallback: find first node and material
                try {
                    const nodeCursor = db.prepare("SELECT _PW_ID, NodeMaterialUuid FROM Node ORDER BY _PW_ID ASC LIMIT 1");
                    let nodeId, nodeUuid;
                    if (nodeCursor.step()) {
                        const nodeResult = nodeCursor.get();
                        nodeId = nodeResult[0];
                        nodeUuid = nodeResult[1] || UUIDUtils.generateUuid();
                    }
                    nodeCursor.free();
                    
                    const matCursor = db.prepare("SELECT _PW_ID, MaterialUuid FROM MaterialFile ORDER BY _PW_ID ASC LIMIT 1");
                    let matId, matUuid;
                    if (matCursor.step()) {
                        const matResult = matCursor.get();
                        matId = matResult[0];
                        matUuid = matResult[1] || UUIDUtils.generateUuid();
                    }
                    matCursor.free();
                    
                    if (nodeId && matId) {
                        return {
                            node_id: nodeId,
                            node_uuid: nodeUuid,
                            material_id: matId,
                            material_uuid: matUuid
                        };
                    }
                } catch (e) {
                    Logger.warning('Error finding fallback nodes');
                }
                
                return null;
            },
            hasVariantTable(db) {
                try {
                    const cursor = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='Variant'");
                    const exists = cursor.step();
                    cursor.free();
                    return exists;
                } catch (e) {
                    return false;
                }
            },
            hasManagerTable(db) {
                try {
                    const cursor = db.prepare("SELECT name FROM sqlite_master WHERE type='table' AND name='Manager'");
                    const exists = cursor.step();
                    cursor.free();
                    return exists;
                } catch (e) {
                    return false;
                }
            },
            updateBrushParameters(db, nodeInfo, params) {
                try {
                    // Get or create VariantID
                    let variantId = null;
                    const cursor = db.prepare("SELECT NodeVariantID FROM Node WHERE _PW_ID = ?");
                    cursor.bind([nodeInfo.node_id]);
                    if (cursor.step()) {
                        variantId = cursor.get()[0];
                    }
                    cursor.free();
                    
                    if (!variantId || variantId === null) {
                        variantId = UUIDUtils.generateUuid().replace(/-/g, '');
                        db.run("UPDATE Node SET NodeVariantID = ? WHERE _PW_ID = ?", [variantId, nodeInfo.node_id]);
                    }
                    
                    // Create or update variant parameters
                    // This is a simplified version - real CSP has many more parameters
                    const variantParams = {
                        brushSize: params.brushSize || 50,
                        opacity: params.opacity || 80,
                        spacing: params.spacing || 10,
                        hardness: params.hardness || 50,
                        angle: params.angle || 0,
                        density: params.density || 100,
                        wetMix: (params.wetMix || 0) / 100, // Convert to 0-1 range
                        textureMode: params.textureMode ? 1 : 0,
                        sizePressure: params.sizePressure ? 1 : 0,
                        opacityPressure: params.opacityPressure ? 1 : 0,
                        densityPressure: params.densityPressure ? 1 : 0
                    };
                    
                    // Create BLOB data for variant
                    const blobData = this.createVariantBlob(variantParams, params);
                    
                    // Check if variant exists
                    let variantExists = false;
                    const checkCursor = db.prepare("SELECT _PW_ID FROM Variant WHERE VariantID = ?");
                    checkCursor.bind([variantId]);
                    variantExists = checkCursor.step();
                    checkCursor.free();
                    
                    if (variantExists) {
                        // Update existing variant
                        db.run("UPDATE Variant SET VariantData = ? WHERE VariantID = ?", [blobData, variantId]);
                    } else {
                        // Insert new variant
                        db.run("INSERT INTO Variant (VariantID, VariantData) VALUES (?, ?)", [variantId, blobData]);
                    }
                } catch (error) {
                    Logger.warning(`Error updating brush parameters: ${error.message}`);
                    // Continue anyway - the brush will still work with default parameters
                }
            },
            createVariantBlob(params, settings) {
                // This creates a simplified binary blob for CSP variant data
                // Real CSP variant data is much more complex
                const data = new DataView(new ArrayBuffer(256));
                let offset = 0;
                
                // Write basic parameters as 32-bit floats
                data.setFloat32(offset, params.brushSize, true); offset += 4;
                data.setFloat32(offset, params.opacity / 100, true); offset += 4;
                data.setFloat32(offset, params.spacing / 100, true); offset += 4;
                data.setFloat32(offset, params.hardness / 100, true); offset += 4;
                data.setFloat32(offset, params.angle * Math.PI / 180, true); offset += 4;
                data.setFloat32(offset, params.density / 100, true); offset += 4;
                data.setFloat32(offset, params.wetMix, true); offset += 4;
                
                // Write boolean flags
                data.setUint8(offset++, params.textureMode);
                data.setUint8(offset++, params.sizePressure);
                data.setUint8(offset++, params.opacityPressure);
                data.setUint8(offset++, params.densityPressure);
                
                // Add pressure curves
                const sizeCurve = PressureCurveUtils.getCurveData('size');
                const opacityCurve = PressureCurveUtils.getCurveData('opacity');
                const densityCurve = PressureCurveUtils.getCurveData('density');
                
                // Write curve data lengths and data
                data.setUint16(offset, sizeCurve.length, true); offset += 2;
                for (let i = 0; i < sizeCurve.length; i++) {
                    data.setUint8(offset++, sizeCurve[i]);
                }
                
                data.setUint16(offset, opacityCurve.length, true); offset += 2;
                for (let i = 0; i < opacityCurve.length; i++) {
                    data.setUint8(offset++, opacityCurve[i]);
                }
                
                data.setUint16(offset, densityCurve.length, true); offset += 2;
                for (let i = 0; i < densityCurve.length; i++) {
                    data.setUint8(offset++, densityCurve[i]);
                }
                
                return new Uint8Array(data.buffer.slice(0, offset));
            }
        };
        
        // Main converter
        const Converter = {
            async convertAll() {
                if (AppState.converting) return;
                
                AppState.converting = true;
                AppState.abortController = new AbortController();
                UI.elements.convertBtn.disabled = true;
                UI.elements.cancelBtn.disabled = false;
                UI.showProgress(0);
                
                try {
                    Logger.info('Starting conversion process...');
                    
                    // Parse brushes from files
                    UI.showStatus('Parsing brushes...', 'info');
                    const brushes = await BrushParser.parse(AppState.files);
                    AppState.brushes = brushes;
                    
                    if (brushes.length === 0) {
                        Logger.warning('No brushes found to convert');
                        UI.showStatus('No brushes found to convert', 'warning');
                        return;
                    }
                    
                    // Get conversion parameters
                    const params = this.getParameters();
                    const format = UI.elements.outputFormat.value;
                    
                    if (format === 'sut') {
                        await this.convertToSUT(brushes, params);
                    } else if (format === 'png') {
                        await this.convertToPNG(brushes);
                    }
                    
                    Logger.success('Conversion completed successfully');
                    UI.showStatus('Conversion completed successfully', 'success');
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        Logger.error('Conversion failed: ' + error.message);
                        UI.showStatus('Conversion failed: ' + error.message, 'error');
                    }
                } finally {
                    AppState.converting = false;
                    AppState.abortController = null;
                    UI.elements.convertBtn.disabled = false;
                    UI.elements.cancelBtn.disabled = true;
                    UI.showProgress(100);
                    setTimeout(() => {
                        UI.elements.progressBar.classList.remove('show');
                    }, 2000);
                }
            },
            async convertToSUT(brushes, params) {
                const zip = new JSZip();
                const failedBrushes = [];
                let converted = 0;
                
                UI.showStatus('Converting brushes to SUT format...', 'info');
                
                for (let i = 0; i < brushes.length; i++) {
                    if (AppState.abortController?.signal.aborted) {
                        throw new Error('Conversion cancelled');
                    }
                    
                    const brush = brushes[i];
                    try {
                        Logger.info(`Converting brush ${i + 1}/${brushes.length}: ${brush.name}`);
                        UI.showStatus(`Converting brush ${i + 1}/${brushes.length}: ${brush.name}`, 'info');
                        
                        const sutBlob = await SUTConverter.createSUT(brush, params);
                        const fileName = `${UI.sanitizeName(brush.name)}.sut`;
                        zip.file(fileName, sutBlob);
                        
                        converted++;
                        AppState.stats.brushesConverted = converted;
                        UI.updateStats();
                        
                        UI.showProgress((i + 1) / brushes.length * 100);
                    } catch (error) {
                        Logger.error(`Failed to convert ${brush.name}: ${error.message}`);
                        failedBrushes.push({ name: brush.name, error: error.message });
                    }
                }
                
                // Show failed brushes if any
                UI.showFailedBrushes(failedBrushes);
                
                if (converted > 0) {
                    // Generate and download ZIP
                    const packageName = UI.sanitizeName(document.getElementById('packageName').value || 'Brushes');
                    const zipBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: parseInt(document.getElementById('compressionLevel').value) }
                    });
                    
                    const downloadUrl = URL.createObjectURL(zipBlob);
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = `${packageName}.zip`;
                    link.click();
                    
                    URL.revokeObjectURL(downloadUrl);
                    Logger.success(`Successfully converted ${converted} brushes to SUT format`);
                }
            },
            async convertToPNG(brushes) {
                const zip = new JSZip();
                let converted = 0;
                
                UI.showStatus('Exporting brush tips as PNG...', 'info');
                
                for (let i = 0; i < brushes.length; i++) {
                    if (AppState.abortController?.signal.aborted) {
                        throw new Error('Conversion cancelled');
                    }
                    
                    const brush = brushes[i];
                    try {
                        Logger.info(`Exporting PNG ${i + 1}/${brushes.length}: ${brush.name}`);
                        UI.showStatus(`Exporting PNG ${i + 1}/${brushes.length}: ${brush.name}`, 'info');
                        
                        // Convert data URL to blob
                        const response = await fetch(brush.tipPNG, { signal: AppState.abortController?.signal });
                        const blob = await response.blob();
                        
                        const fileName = `${UI.sanitizeName(brush.name)}.png`;
                        zip.file(fileName, blob);
                        
                        converted++;
                        AppState.stats.brushesConverted = converted;
                        UI.updateStats();
                        
                        UI.showProgress((i + 1) / brushes.length * 100);
                    } catch (error) {
                        Logger.error(`Failed to export ${brush.name}: ${error.message}`);
                    }
                }
                
                if (converted > 0) {
                    // Generate and download ZIP
                    const packageName = UI.sanitizeName(document.getElementById('packageName').value || 'Brushes');
                    const zipBlob = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: parseInt(document.getElementById('compressionLevel').value) }
                    });
                    
                    const downloadUrl = URL.createObjectURL(zipBlob);
                    const link = document.createElement('a');
                    link.href = downloadUrl;
                    link.download = `${packageName}_tips.zip`;
                    link.click();
                    
                    URL.revokeObjectURL(downloadUrl);
                    Logger.success(`Successfully exported ${converted} PNG brush tips`);
                }
            },
            getParameters() {
                return {
                    brushSize: parseInt(document.getElementById('brushSize').value),
                    opacity: parseInt(document.getElementById('opacity').value),
                    spacing: parseInt(document.getElementById('spacing').value),
                    hardness: parseInt(document.getElementById('hardness').value),
                    angle: parseInt(document.getElementById('angle').value),
                    density: parseInt(document.getElementById('density').value),
                    wetMix: parseInt(document.getElementById('wetMix').value),
                    textureMode: document.getElementById('textureMode').checked,
                    sizePressure: document.getElementById('sizePressure').checked,
                    opacityPressure: document.getElementById('opacityPressure').checked,
                    densityPressure: document.getElementById('densityPressure').checked
                };
            }
        };
    </script>
</body>
</html>
