
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSP Brush Converter Pro - Fixed Version</title>
    <meta name="description" content="Convert Procreate, Photoshop ABR, and custom brushes to Clip Studio Paint format">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
             background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;color:#fff}
        .container{max-width:1200px;margin:0 auto;background:rgba(255,255,255,.95);
                   border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,.3);overflow:hidden}
        .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:30px;text-align:center}
        .header h1{font-size:clamp(1.5em,4vw,2.5em);margin-bottom:10px;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,.2)}
        .header p{opacity:.9;font-size:1.1em}
        .content{padding:clamp(20px,4vw,40px);color:#333}
        #dropZone{border:3px dashed #667eea;border-radius:15px;padding:clamp(40px,8vw,60px) clamp(20px,4vw,30px);
                  text-align:center;background:linear-gradient(135deg,#f5f7fa 0%,#c3cfe2 100%);
                  transition:all .3s;cursor:pointer;margin-bottom:30px}
        #dropZone:hover{border-color:#764ba2;transform:translateY(-2px);box-shadow:0 10px 30px rgba(102,126,234,.3)}
        #dropZone.dragover{border-color:#00d4ff;background:linear-gradient(135deg,#e0f7fa 0%,#b2ebf2 100%);transform:scale(1.02)}
        #dropZone svg{width:clamp(48px,8vw,64px);height:clamp(48px,8vw,64px);margin-bottom:20px;opacity:.7}
        .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:20px;margin-bottom:30px}
        .control-group{background:#f8f9fa;padding:20px;border-radius:10px;border:1px solid #e9ecef}
        .control-group label{display:block;font-weight:600;margin-bottom:10px;color:#495057}
        select,input[type=text]{width:100%;padding:12px;border:2px solid #dee2e6;border-radius:8px;font-size:1em;transition:border-color .3s}
        select:focus,input[type=text]:focus{outline:none;border-color:#667eea}
        .btn{padding:15px 40px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
             color:#fff;border:none;border-radius:10px;cursor:pointer;font-size:1.1em;font-weight:600;
             transition:all .3s;box-shadow:0 4px 15px rgba(102,126,234,.4);display:inline-flex;align-items:center;gap:10px;width:100%;justify-content:center}
        .btn:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 20px rgba(102,126,234,.6)}
        .btn:disabled{background:#adb5bd;cursor:not-allowed;box-shadow:none}
        .file-input-group{display:flex;gap:10px;margin-top:20px}
        .file-input-group .btn{flex:1}
        .status-bar{background:#e9ecef;padding:15px;border-radius:8px;margin-bottom:20px;display:none;align-items:center;gap:10px}
        .status-bar.show{display:flex}
        .status-bar.success{background:#d4edda;color:#155724}
        .status-bar.error{background:#f8d7da;color:#721c24}
        .status-bar.info{background:#d1ecf1;color:#0c5460}
        #log{background:#1e1e1e;padding:20px;border-radius:10px;max-height:400px;overflow-y:auto;
             font-family:'Courier New',monospace;font-size:.9em;line-height:1.6}
        .log-entry{padding:5px 0;border-left:3px solid transparent;padding-left:10px;margin-bottom:5px}
        .log-entry.success{color:#4caf50;border-color:#4caf50}
        .log-entry.info{color:#2196f3;border-color:#2196f3}
        .log-entry.error{color:#f44336;border-color:#f44336}
        .log-entry.warning{color:#ff9800;border-color:#ff9800}
        .stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin-bottom:30px}
        .stat-card{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);padding:20px;border-radius:10px;color:#fff;text-align:center}
        .stat-card .value{font-size:clamp(1.5em,3vw,2em);font-weight:bold;margin-bottom:5px}
        .stat-card .label{opacity:.9;font-size:.9em}
        .progress-bar{width:100%;height:8px;background:#e9ecef;border-radius:4px;overflow:hidden;margin-top:10px;display:none}
        .progress-bar.show{display:block}
        .progress-fill{height:100%;background:linear-gradient(90deg,#667eea 0%,#764ba2 100%);width:0%;transition:width .3s}
        .format-info{margin-top:10px;padding:10px;background:#e3f2fd;border-radius:5px;font-size:.9em;color:#1565c0}
        .warning-box{margin-top:10px;padding:10px;background:#fff3cd;border-radius:5px;font-size:.85em;color:#856404}
        .footer{text-align:center;padding:20px;margin-top:30px;color:rgba(255,255,255,.7);font-size:.9em}
        .import-options{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px;margin-top:15px}
        @media(max-width:768px){.controls{grid-template-columns:1fr}.file-input-group{flex-direction:column}.import-options{grid-template-columns:1fr}}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CSP Brush Converter Pro</h1>
            <p>Fixed version - Import and convert brushes to Clip Studio Paint format</p>
        </div>
        <div class="content">
            <div id="dropZone">
                <svg fill="currentColor" viewBox="0 0 20 20"><path d="M16.88 9.1A4 4 0 0 1 16 17H5a5 5 0 0 1-1-9.9V7a3 3 0 0 1 4.52-2.59A4.98 4.98 0 0 1 17 8c0 .38-.04.74-.12 1.1zM11 11h3l-4-4-4 4h3v3h2v-3z"/></svg>
                <h2 style="color:#667eea;margin-bottom:10px">Drop Files Here</h2>
                <p style="color:#6c757d;margin-bottom:20px">Supports: .brushset, .zip, .abr, .brush, .png</p>
                
                <div class="import-options">
                    <button class="btn" id="importFilesBtn">Import Files</button>
                    <button class="btn" id="importZipBtn">Import ZIP</button>
                    <button class="btn" id="importFolderBtn">Import Folder</button>
                </div>
                
                <input type="file" id="fileInput" multiple accept=".brushset,.zip,.abr,.brush,.json,.png" style="display:none">
                <input type="file" id="zipInput" accept=".zip,.brushset" style="display:none">
                <input type="file" id="folderInput" webkitdirectory directory style="display:none">
            </div>

            <div class="stats" id="stats" style="display:none">
                <div class="stat-card"><div class="value" id="fileCount">0</div><div class="label">Files Loaded</div></div>
                <div class="stat-card"><div class="value" id="brushCount">0</div><div class="label">Brushes Found</div></div>
                <div class="stat-card"><div class="value" id="convertedCount">0</div><div class="label">Converted</div></div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="targetFormat">Output Format</label>
                    <select id="targetFormat">
                        <option value="sut">Clip Studio Paint (.sut) - Full</option>
                        <option value="png">Brush Tip PNGs Only</option>
                    </select>
                    <div class="format-info" id="formatInfo"></div>
                </div>
                <div class="control-group">
                    <label for="packageName">Package Name</label>
                    <input type="text" id="packageName" placeholder="My Custom Brushes" value="Converted Brushes">
                </div>
                <div class="control-group">
                    <label for="authorName">Author Name</label>
                    <input type="text" id="authorName" placeholder="Artist Name">
                </div>
                <div class="control-group">
                    <label for="compressionLevel">Compression</label>
                    <select id="compressionLevel">
                        <option value="1">Fast</option>
                        <option value="6" selected>Balanced</option>
                        <option value="9">Maximum</option>
                    </select>
                </div>
            </div>

            <button id="convertBtn" class="btn" disabled>Convert & Download</button>
            <div class="progress-bar" id="progressBar"><div class="progress-fill" id="progressFill"></div></div>
            <div id="statusBar" class="status-bar"><span id="statusText">Ready</span></div>
            <div id="log"></div>
        </div>
        <div class="footer">
            <p>CSP Brush Converter Pro - Fixed Version | All processing happens in your browser - no files are uploaded</p>
        </div>
    </div>

    <script>
        /*=====================================================================
          GLOBAL INIT
        =====================================================================*/
        let SQL, SQL_READY = false;
        
        /*=====================================================================
          STATE & UI
        =====================================================================*/
        const AppState = {
            files: [], 
            brushes: [], 
            filesLoaded: false, 
            converting: false,
            stats: {
                filesLoaded: 0,
                brushesParsed: 0, 
                brushesConverted: 0, 
                placeholderTips: 0
            }
        };

        const UI = {
            e: {
                dropZone: document.getElementById('dropZone'),
                fileInput: document.getElementById('fileInput'),
                zipInput: document.getElementById('zipInput'),
                folderInput: document.getElementById('folderInput'),
                importFilesBtn: document.getElementById('importFilesBtn'),
                importZipBtn: document.getElementById('importZipBtn'),
                importFolderBtn: document.getElementById('importFolderBtn'),
                convertBtn: document.getElementById('convertBtn'),
                log: document.getElementById('log'),
                statusBar: document.getElementById('statusBar'),
                statusText: document.getElementById('statusText'),
                progressBar: document.getElementById('progressBar'),
                progressFill: document.getElementById('progressFill'),
                stats: document.getElementById('stats'),
                fileCount: document.getElementById('fileCount'),
                brushCount: document.getElementById('brushCount'),
                convertedCount: document.getElementById('convertedCount'),
                formatInfo: document.getElementById('formatInfo'),
                targetFormat: document.getElementById('targetFormat')
            },
            init() {
                this.e.targetFormat.addEventListener('change', () => {
                    this.updateFormatInfo();
                });
                this.updateFormatInfo();
            },
            updateFormatInfo() {
                const info = {
                    'sut': 'Full CSP brush files with metadata',
                    'png': 'Brush tip images only'
                };
                this.e.formatInfo.textContent = info[this.e.targetFormat.value] || '';
            },
            sanitizeName(n) {
                return n.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]))
                       .replace(/[<>:"/\\|?*]/g, '_')
                       .replace(/\s+/g, ' ')
                       .substring(0, 100)
                       .trim() || 'Brush';
            },
            showStatus(m, t = 'info') {
                this.e.statusBar.className = `status-bar show ${t}`;
                this.e.statusText.textContent = m;
            },
            showProgress(p) {
                this.e.progressBar.classList.add('show');
                this.e.progressFill.style.width = p + '%';
            },
            updateStats() {
                this.e.stats.style.display = 'grid';
                this.e.fileCount.textContent = AppState.stats.filesLoaded;
                this.e.brushCount.textContent = AppState.stats.brushesParsed;
                this.e.convertedCount.textContent = AppState.stats.brushesConverted;
            },
            enableConvertButton() {
                this.e.convertBtn.disabled = false;
            },
            disableConvertButton() {
                this.e.convertBtn.disabled = true;
            }
        };

        /*=====================================================================
          LOGGER
        =====================================================================*/
        const Logger = {
            log(m, t = 'info') {
                const e = document.createElement('div');
                e.className = `log-entry ${t}`;
                e.textContent = `[${new Date().toLocaleTimeString()}] ${m}`;
                UI.e.log.appendChild(e);
                UI.e.log.scrollTop = UI.e.log.scrollHeight;
            },
            info(m) { this.log(m, 'info'); },
            success(m) { this.log(m, 'success'); },
            error(m) { this.log(m, 'error'); },
            warning(m) { this.log(m, 'warning'); },
            clear() { UI.e.log.innerHTML = ''; }
        };

        /*=====================================================================
          UUID HANDLING
        =====================================================================*/
        const UUIDUtils = { 
            uuidToBlob: function(uuid) {
                const clean = uuid.replace(/-/g, '');
                if (clean.length !== 32) return this.generateUuidBlob();
                const bytes = new Uint8Array(16);
                for (let i = 0; i < 16; i++) bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
                return bytes.buffer;
            },
            blobToUuid: function(blob) {
                const bytes = new Uint8Array(blob);
                let uuid = '';
                for (let i = 0; i < 16; i++) uuid += bytes[i].toString(16).padStart(2, '0');
                return `${uuid.substr(0,8)}-${uuid.substr(8,4)}-${uuid.substr(12,4)}-${uuid.substr(16,4)}-${uuid.substr(20,12)}`;
            },
            generateUuidBlob: function() {
                const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                    const r = Math.random() * 16 | 0;
                    const v = c === 'x' ? r : (r & 0x3 | 0x8);
                    return v.toString(16);
                });
                return this.uuidToBlob(uuid);
            }
        };

        /*=====================================================================
          IMAGE VALIDATOR - FIXED VERSION
        =====================================================================*/
        const ImageValidator = {
            async validateAlphaAndOptimise(data) {
                return new Promise((resolve, reject) => {
                    try {
                        // Create blob from the data
                        const blob = new Blob([data], { type: 'image/png' });
                        const img = new Image();
                        const url = URL.createObjectURL(blob);
                        
                        img.onload = () => {
                            URL.revokeObjectURL(url);
                            
                            // Create canvas for manipulation
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.min(img.width, 512);
                            canvas.height = Math.min(img.height, 512);
                            const ctx = canvas.getContext('2d');
                            
                            // Draw image to canvas
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            
                            // Get image data for alpha check
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            let hasAlpha = false;
                            
                            for (let i = 3; i < imageData.data.length; i += 4) {
                                if (imageData.data[i] < 255) {
                                    hasAlpha = true;
                                    break;
                                }
                            }
                            
                            // If no alpha channel, add one based on luminance
                            if (!hasAlpha) {
                                Logger.warning('No alpha channel detected - adding transparency based on luminance');
                                
                                for (let i = 0; i < imageData.data.length; i += 4) {
                                    // Convert to grayscale for alpha
                                    const r = imageData.data[i];
                                    const g = imageData.data[i + 1];
                                    const b = imageData.data[i + 2];
                                    const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                                    
                                    // Set RGB to white, alpha based on luminance
                                    imageData.data[i] = 255;     // R
                                    imageData.data[i + 1] = 255; // G
                                    imageData.data[i + 2] = 255; // B
                                    imageData.data[i + 3] = 255 - Math.round(luminance); // A (inverted)
                                }
                                
                                ctx.putImageData(imageData, 0, 0);
                            }
                            
                            // Convert back to blob
                            canvas.toBlob(resultBlob => {
                                if (resultBlob) {
                                    resultBlob.arrayBuffer().then(resolve).catch(reject);
                                } else {
                                    reject(new Error('Failed to convert canvas to blob'));
                                }
                            }, 'image/png', 0.9); // 90% quality for optimization
                        };
                        
                        img.onerror = () => {
                            URL.revokeObjectURL(url);
                            reject(new Error('Failed to load image'));
                        };
                        
                        img.src = url;
                    } catch (error) {
                        reject(error);
                    }
                });
            }
        };

        /*=====================================================================
          FILE MANAGER - FIXED VERSION
        =====================================================================*/
        const FileManager = {
            ZIP_EXTENSIONS: ['zip', 'brushset', 'brush'],
            
            async handleFiles(files) {
                Logger.clear();
                UI.showStatus('Loading files...', 'info');
                UI.disableConvertButton();
                AppState.files = [];
                AppState.stats.filesLoaded = 0;
                
                try {
                    for (const file of files) {
                        const ext = file.name.split('.').pop().toLowerCase();
                        if (file.size === 0) {
                            Logger.warning(`Skipping empty file: ${file.name}`);
                            continue;
                        }
                        
                        if (this.ZIP_EXTENSIONS.includes(ext)) {
                            await this.extractZip(file);
                        } else {
                            await this.addFile(file);
                        }
                    }
                    
                    AppState.stats.filesLoaded = AppState.files.length;
                    AppState.filesLoaded = true;
                    UI.updateStats();
                    Logger.success(`Loaded ${AppState.files.length} files`);
                    
                    if (AppState.files.length > 0 && SQL_READY) {
                        UI.enableConvertButton();
                        UI.showStatus('Ready to convert', 'success');
                    } else if (!SQL_READY) {
                        UI.showStatus('Waiting for SQL engine to load...', 'info');
                    } else {
                        UI.showStatus('No valid files loaded', 'error');
                    }
                } catch (error) {
                    Logger.error('Error loading files: ' + error.message);
                    UI.showStatus('Error loading files', 'error');
                }
            },
            
            async addFile(file) {
                const maxSize = 50 * 1024 * 1024; // 50MB limit
                
                if (file.size > maxSize) {
                    Logger.warning(`File ${file.name} is too large (${(file.size / 1024 / 1024).toFixed(2)}MB), skipping`);
                    return;
                }
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const content = new Uint8Array(arrayBuffer);
                    
                    AppState.files.push({
                        name: file.name,
                        path: file.webkitRelativePath || file.name,
                        content: content,
                        size: file.size
                    });
                    
                    Logger.info(`Added file: ${file.name} (${(file.size / 1024).toFixed(1)}KB)`);
                } catch (error) {
                    Logger.warning(`Failed to read file: ${file.name} - ${error.message}`);
                }
            },
            
            async extractZip(file) {
                Logger.info(`Extracting ZIP: ${file.name}`);
                
                if (file.size > 100 * 1024 * 1024) { // 100MB limit for ZIPs
                    Logger.warning(`ZIP file ${file.name} is too large (${(file.size / 1024 / 1024).toFixed(2)}MB), skipping`);
                    return;
                }
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const zip = await JSZip.loadAsync(arrayBuffer);
                    const promises = [];
                    
                    let fileCount = 0;
                    zip.forEach((relativePath, zipEntry) => {
                        if (!zipEntry.dir) {
                            fileCount++;
                            promises.push(
                                zipEntry.async('uint8array').then(content => {
                                    // Skip files larger than 10MB inside ZIP
                                    if (content.length > 10 * 1024 * 1024) {
                                        Logger.warning(`Skipping large file in ZIP: ${relativePath}`);
                                        return;
                                    }
                                    
                                    AppState.files.push({
                                        name: relativePath.split('/').pop(),
                                        path: relativePath,
                                        content: content,
                                        size: content.length
                                    });
                                }).catch(error => {
                                    Logger.warning(`Failed to extract ${relativePath} from ZIP: ${error.message}`);
                                })
                            );
                        }
                    });
                    
                    await Promise.allSettled(promises);
                    Logger.success(`Extracted ${AppState.files.length} files from ${file.name}`);
                } catch (error) {
                    Logger.error(`ZIP extraction failed: ${error.message}`);
                }
            }
        };

        /*=====================================================================
          BRUSH PARSER - FIXED VERSION
        =====================================================================*/
        const BrushParser = {
            blobUrls: [],
            
            async parse(files) {
                this.cleanup();
                Logger.info('Parsing brush files...');
                
                const brushes = [];
                const usedNames = new Set();
                
                // Filter to only process relevant files
                const brushFiles = files.filter(file => {
                    const ext = file.name.toLowerCase();
                    return ext.endsWith('.png') || ext.endsWith('.abr') || ext.endsWith('.json');
                });
                
                if (brushFiles.length === 0) {
                    Logger.warning('No brush files found in uploaded files');
                    return brushes;
                }
                
                for (const file of brushFiles) {
                    try {
                        if (file.name.toLowerCase().endsWith('.png')) {
                            const brush = await this.createBrushFromPNG(file, usedNames);
                            if (brush) brushes.push(brush);
                        }
                        else if (file.name.toLowerCase().endsWith('.abr')) {
                            const brush = await this.createBrushFromABR(file, usedNames);
                            if (brush) brushes.push(brush);
                        }
                        else if (file.name.toLowerCase().endsWith('.json')) {
                            const jsonBrushes = await this.parseJSON(file);
                            brushes.push(...jsonBrushes);
                        }
                    } catch (error) {
                        Logger.warning(`Failed to process ${file.name}: ${error.message}`);
                    }
                }
                
                AppState.stats.brushesParsed = brushes.length;
                
                if (brushes.length > 0) {
                    Logger.success(`Parsed ${brushes.length} brushes`);
                } else {
                    Logger.warning('No valid brushes could be parsed from the files');
                }
                
                return brushes;
            },
            
            async createBrushFromPNG(file, usedNames) {
                try {
                    const optimized = await ImageValidator.validateAlphaAndOptimise(file.content);
                    const blob = new Blob([optimized], { type: 'image/png' });
                    const tipUrl = URL.createObjectURL(blob);
                    this.blobUrls.push(tipUrl);
                    
                    let name = this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames);
                    
                    return {
                        name: name,
                        brushSize: 50,
                        opacity: 80,
                        spacing: 25,
                        hardness: 50,
                        tipPNG: tipUrl
                    };
                } catch (error) {
                    Logger.warning(`Failed to process PNG ${file.name}: ${error.message}`);
                    return null;
                }
            },
            
            async createBrushFromABR(file, usedNames) {
                // Simple ABR handling - treat as image file
                try {
                    // Try to find PNG data in ABR file
                    const data = file.content;
                    let pngStart = -1;
                    
                    // Look for PNG signature
                    for (let i = 0; i < data.length - 8; i++) {
                        if (data[i] === 0x89 && data[i+1] === 0x50 && data[i+2] === 0x4E && data[i+3] === 0x47) {
                            pngStart = i;
                            break;
                        }
                    }
                    
                    if (pngStart !== -1) {
                        // Found PNG data, extract it
                        let pngEnd = pngStart;
                        while (pngEnd < data.length - 8) {
                            if (data[pngEnd] === 0x49 && data[pngEnd+1] === 0x45 && data[pngEnd+2] === 0x4E && data[pngEnd+3] === 0x44) {
                                pngEnd += 8; // PNG end marker
                                break;
                            }
                            pngEnd++;
                        }
                        
                        const pngData = data.slice(pngStart, pngEnd);
                        const optimized = await ImageValidator.validateAlphaAndOptimise(pngData);
                        const blob = new Blob([optimized], { type: 'image/png' });
                        const tipUrl = URL.createObjectURL(blob);
                        this.blobUrls.push(tipUrl);
                        
                        let name = this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames);
                        
                        return {
                            name: name,
                            brushSize: 50,
                            opacity: 80,
                            spacing: 25,
                            hardness: 50,
                            tipPNG: tipUrl
                        };
                    } else {
                        // No PNG found, use placeholder
                        Logger.warning(`No PNG data found in ABR file ${file.name}, using placeholder`);
                        return this.createPlaceholderBrush(file, usedNames);
                    }
                } catch (error) {
                    Logger.warning(`Failed to process ABR ${file.name}: ${error.message}`);
                    return this.createPlaceholderBrush(file, usedNames);
                }
            },
            
            async parseJSON(file) {
                try {
                    const text = new TextDecoder().decode(file.content);
                    const data = JSON.parse(text);
                    const brushes = [];
                    
                    if (data.name && (data.brushSize || data.size)) {
                        brushes.push({
                            name: UI.sanitizeName(data.name),
                            brushSize: data.brushSize || data.size || 50,
                            opacity: data.opacity || 80,
                            spacing: data.spacing || 25,
                            hardness: data.hardness || 50,
                            tipPNG: this.createPlaceholderTip()
                        });
                    } else if (Array.isArray(data)) {
                        data.forEach(brush => {
                            if (brush.name && (brush.brushSize || brush.size)) {
                                brushes.push({
                                    name: UI.sanitizeName(brush.name),
                                    brushSize: brush.brushSize || brush.size || 50,
                                    opacity: brush.opacity || 80,
                                    spacing: brush.spacing || 25,
                                    hardness: brush.hardness || 50,
                                    tipPNG: this.createPlaceholderTip()
                                });
                            }
                        });
                    }
                    
                    return brushes;
                } catch (error) {
                    Logger.warning(`Failed to parse JSON ${file.name}: ${error.message}`);
                    return [];
                }
            },
            
            createPlaceholderBrush(file, usedNames) {
                const tipUrl = this.createPlaceholderTip();
                let name = this.getUniqueName(file.name.replace(/\.[^/.]+$/, ""), usedNames);
                
                return {
                    name: name,
                    brushSize: 50,
                    opacity: 80,
                    spacing: 25,
                    hardness: 50,
                    tipPNG: tipUrl
                };
            },
            
            getUniqueName(baseName, usedNames) {
                let name = UI.sanitizeName(baseName);
                let suffix = 1;
                let finalName = name;
                
                while (usedNames.has(finalName)) {
                    finalName = `${name}_${suffix}`;
                    suffix++;
                }
                
                usedNames.add(finalName);
                return finalName;
            },
            
            createPlaceholderTip() {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 200);
                gradient.addColorStop(0, 'rgba(255,255,255,1)');
                gradient.addColorStop(0.7, 'rgba(200,200,200,1)');
                gradient.addColorStop(1, 'rgba(255,255,255,0)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 512, 512);
                
                const url = canvas.toDataURL('image/png');
                // For data URLs, we don't need to add to blobUrls or revoke
                return url;
            },
            
            cleanup() {
                // Only revoke object URLs, not data URLs
                this.blobUrls.forEach(url => {
                    if (url.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(url);
                        } catch (e) {
                            // Ignore errors when revoking URLs
                        }
                    }
                });
                this.blobUrls = [];
            }
        };

        /*=====================================================================
          SUT CONVERTER - FIXED VERSION
        =====================================================================*/
        const SUTConverter = {
            async createSUT(brush) {
                if (!SQL_READY) {
                    throw new Error('SQL engine not ready');
                }
                
                const db = new SQL.Database();
                
                try {
                    // Start transaction
                    db.exec("BEGIN TRANSACTION");
                    
                    // Create CSP-compatible database schema
                    db.run(`CREATE TABLE Manager(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        ToolType INTEGER,
                        Version INTEGER,
                        RootUuid BLOB,
                        CurrentNodeUuid BLOB
                    )`);
                    
                    db.run(`CREATE TABLE Node(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        NodeUuid BLOB,
                        NodeName TEXT,
                        NodeMaterialUuid TEXT
                    )`);
                    
                    db.run(`CREATE TABLE MaterialFile(
                        _PW_ID INTEGER PRIMARY KEY AUTOINCREMENT,
                        FileData BLOB,
                        MaterialUuid TEXT
                    )`);
                    
                    // Generate UUIDs
                    const rootUuid = UUIDUtils.generateUuidBlob();
                    const nodeUuid = UUIDUtils.generateUuidBlob();
                    const materialUuid = UUIDUtils.generateUuidBlob();
                    
                    // Insert manager data
                    db.run(`INSERT INTO Manager (ToolType, Version, RootUuid, CurrentNodeUuid) 
                           VALUES (2, 1, ?, ?)`, [rootUuid, nodeUuid]);
                    
                    // Insert node data
                    db.run(`INSERT INTO Node (NodeUuid, NodeName, NodeMaterialUuid) 
                           VALUES (?, ?, ?)`, [nodeUuid, brush.name, UUIDUtils.blobToUuid(materialUuid)]);
                    
                    // Get image data
                    let imageData = null;
                    try {
                        const response = await fetch(brush.tipPNG);
                        if (response.ok) {
                            imageData = await response.arrayBuffer();
                        } else {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                    } catch (error) {
                        Logger.warning(`Could not fetch image for ${brush.name}: ${error.message}`);
                        // Create a simple placeholder image
                        imageData = await this.createPlaceholderImage();
                    }
                    
                    // Insert material data
                    if (imageData) {
                        db.run(`INSERT INTO MaterialFile (FileData, MaterialUuid) 
                               VALUES (?, ?)`, [new Uint8Array(imageData), UUIDUtils.blobToUuid(materialUuid)]);
                    }
                    
                    // Commit transaction and export
                    db.exec("COMMIT");
                    const exported = db.export();
                    
                    return new Blob([exported], { type: 'application/octet-stream' });
                } catch (error) {
                    // Rollback on error
                    try {
                        db.exec("ROLLBACK");
                    } catch (rollbackError) {
                        // Ignore rollback errors
                    }
                    throw error;
                } finally {
                    // Always close the database
                    try {
                        db.close();
                    } catch (closeError) {
                        // Ignore close errors
                    }
                }
            },
            
            async createPlaceholderImage() {
                return new Promise(resolve => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = 512;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, 512, 512);
                    
                    canvas.toBlob(blob => {
                        blob.arrayBuffer().then(resolve);
                    }, 'image/png');
                });
            }
        };

        /*=====================================================================
          MAIN CONVERTER - FIXED VERSION
        =====================================================================*/
        const Converter = {
            async convert(brushes, format) {
                if (brushes.length === 0) {
                    throw new Error('No brushes to convert');
                }
                
                const zip = new JSZip();
                const compressionLevel = parseInt(document.getElementById('compressionLevel').value);
                const totalBrushes = brushes.length;
                
                UI.showProgress(0);
                AppState.stats.brushesConverted = 0;
                UI.updateStats();
                
                for (let i = 0; i < totalBrushes; i++) {
                    const brush = brushes[i];
                    const progress = ((i + 1) / totalBrushes) * 100;
                    UI.showProgress(progress);
                    
                    try {
                        if (format === 'sut') {
                            if (!SQL_READY) {
                                throw new Error('SQL engine not available for SUT conversion');
                            }
                            const sutBlob = await SUTConverter.createSUT(brush);
                            zip.file(`${brush.name}.sut`, sutBlob);
                        } else if (format === 'png') {
                            const pngResponse = await fetch(brush.tipPNG);
                            if (!pngResponse.ok) {
                                throw new Error(`Failed to fetch PNG: ${pngResponse.status}`);
                            }
                            const pngBlob = await pngResponse.blob();
                            zip.file(`${brush.name}.png`, pngBlob);
                        }
                        
                        AppState.stats.brushesConverted++;
                        UI.updateStats();
                        
                        // Yield to UI thread occasionally for better responsiveness
                        if (i % 5 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 10));
                        }
                    } catch (error) {
                        Logger.error(`Failed to convert brush "${brush.name}": ${error.message}`);
                        // Continue with next brush instead of failing completely
                    }
                }
                
                if (AppState.stats.brushesConverted === 0) {
                    throw new Error('No brushes were successfully converted');
                }
                
                UI.showProgress(95);
                
                try {
                    const result = await zip.generateAsync({
                        type: 'blob',
                        compression: 'DEFLATE',
                        compressionOptions: { level: compressionLevel }
                    });
                    
                    UI.showProgress(100);
                    return result;
                } catch (error) {
                    throw new Error(`Failed to create ZIP file: ${error.message}`);
                }
            }
        };

        /*=====================================================================
          EVENT HANDLERS & INITIALIZATION - FIXED VERSION
        =====================================================================*/
        window.addEventListener('load', async () => {
            // Initialize UI first
            UI.init();
            Logger.info('CSP Brush Converter Pro - Fixed Version Initializing...');
            UI.showStatus('Initializing...', 'info');
            
            // Initialize SQL.js with better error handling
            try {
                Logger.info('Loading SQL.js engine...');
                
                // Use the correct CDN URL format
                SQL = await initSqlJs({
                    locateFile: url => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${url}`
                });
                
                SQL_READY = true;
                Logger.success('SQL.js engine loaded successfully');
                
                if (AppState.filesLoaded && AppState.files.length > 0) {
                    UI.enableConvertButton();
                    UI.showStatus('Ready to convert', 'success');
                } else {
                    UI.showStatus('SQL engine ready - load brush files to begin', 'info');
                }
            } catch (error) {
                Logger.error('SQL.js failed to load: ' + error.message);
                UI.showStatus('Limited functionality - PNG export only available', 'warning');
                SQL_READY = false;
                
                // Disable SUT format if SQL isn't available
                const sutOption = UI.e.targetFormat.querySelector('option[value="sut"]');
                if (sutOption) {
                    sutOption.disabled = true;
                    if (UI.e.targetFormat.value === 'sut') {
                        UI.e.targetFormat.value = 'png';
                        UI.updateFormatInfo();
                    }
                }
            }
            
            // Setup button event listeners
            UI.e.importFilesBtn.addEventListener('click', () => {
                UI.e.fileInput.value = '';
                UI.e.fileInput.click();
            });
            
            UI.e.importZipBtn.addEventListener('click', () => {
                UI.e.zipInput.value = '';
                UI.e.zipInput.click();
            });
            
            UI.e.importFolderBtn.addEventListener('click', () => {
                if ('webkitdirectory' in document.createElement('input')) {
                    UI.e.folderInput.value = '';
                    UI.e.folderInput.click();
                } else {
                    alert('Folder import is only supported in Chrome and Edge browsers. Please use the "Import Files" button instead.');
                    Logger.warning('Folder selection not supported in this browser');
                }
            });
            
            // File input change handlers
            const handleFileInput = async (e, source) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    Logger.info(`Selected ${files.length} file(s) from ${source}`);
                    await FileManager.handleFiles(files);
                }
            };
            
            UI.e.fileInput.addEventListener('change', (e) => handleFileInput(e, 'file picker'));
            UI.e.zipInput.addEventListener('change', (e) => handleFileInput(e, 'ZIP file'));
            UI.e.folderInput.addEventListener('change', (e) => handleFileInput(e, 'folder'));
            
            // Drag and drop with better handling
            UI.e.dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                UI.e.dropZone.classList.add('dragover');
            });
            
            UI.e.dropZone.addEventListener('dragleave', () => {
                UI.e.dropZone.classList.remove('dragover');
            });
            
            UI.e.dropZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                UI.e.dropZone.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    Logger.info(`Dropped ${files.length} file(s)`);
                    await FileManager.handleFiles(files);
                }
            });
            
            // Convert button with comprehensive error handling
            UI.e.convertBtn.addEventListener('click', async () => {
                if (AppState.converting) {
                    Logger.warning('Conversion already in progress');
                    return;
                }
                
                AppState.converting = true;
                UI.disableConvertButton();
                BrushParser.cleanup(); // Clean up any previous blob URLs
                
                Logger.clear();
                UI.showStatus('Starting conversion...', 'info');
                
                try {
                    // Parse brushes
                    UI.showStatus('Parsing brush data...', 'info');
                    const brushes = await BrushParser.parse(AppState.files);
                    
                    if (brushes.length === 0) {
                        throw new Error('No valid brushes could be parsed from the uploaded files. Please check that you have uploaded brush files (PNG, ABR, or JSON).');
                    }
                    
                    const format = UI.e.targetFormat.value;
                    const authorName = document.getElementById('authorName').value || 'Converted Brush';
                    let packageName = document.getElementById('packageName').value || 'Converted_Brushes';
                    
                    // Sanitize package name
                    packageName = UI.sanitizeName(packageName);
                    
                    UI.showStatus(`Converting ${brushes.length} brushes to ${format.toUpperCase()}...`, 'info');
                    
                    // Show progress bar
                    UI.e.progressBar.classList.add('show');
                    
                    // Perform conversion
                    const resultBlob = await Converter.convert(brushes, format);
                    
                    // Create download
                    const downloadLink = document.createElement('a');
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
                    const filename = `${packageName}_${format}_${timestamp}.zip`;
                    
                    downloadLink.href = URL.createObjectURL(resultBlob);
                    downloadLink.download = filename;
                    downloadLink.style.display = 'none';
                    
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                    
                    // Clean up the object URL after a short delay
                    setTimeout(() => {
                        try {
                            URL.revokeObjectURL(downloadLink.href);
                        } catch (e) {
                            // Ignore errors when revoking
                        }
                    }, 1000);
                    
                    // Show success
                    const fileSizeMB = (resultBlob.size / (1024 * 1024)).toFixed(2);
                    UI.showStatus(`Conversion complete! Downloaded ${fileSizeMB} MB`, 'success');
                    Logger.success(`Successfully converted ${brushes.length} brushes`);
                    Logger.success(`Output: ${filename} (${fileSizeMB} MB)`);
                    
                } catch (error) {
                    Logger.error('Conversion failed: ' + error.message);
                    UI.showStatus('Conversion failed: ' + error.message, 'error');
                    console.error('Conversion error details:', error);
                } finally {
                    AppState.converting = false;
                    BrushParser.cleanup();
                    
                    // Re-enable convert button if we have files
                    if (AppState.filesLoaded && AppState.files.length > 0) {
                        UI.enableConvertButton();
                    }
                }
            });
            
            Logger.info('CSP Brush Converter Pro - Fixed Version Ready!');
            Logger.info('Drag and drop brush files or use the import buttons above');
            UI.showStatus('Ready - load brush files to begin', 'success');
        });
        
        // Comprehensive cleanup on page unload
        window.addEventListener('beforeunload', () => {
            BrushParser.cleanup();
            
            // Additional cleanup for any remaining blob URLs
            if (AppState.brushes && Array.isArray(AppState.brushes)) {
                AppState.brushes.forEach(brush => {
                    if (brush.tipPNG && brush.tipPNG.startsWith('blob:')) {
                        try {
                            URL.revokeObjectURL(brush.tipPNG);
                        } catch (e) {
                            // Ignore errors
                        }
                    }
                });
            }
        });
        
        // Handle page visibility changes to clean up resources
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'hidden') {
                BrushParser.cleanup();
            }
        });
    </script>
</body>
</html>
